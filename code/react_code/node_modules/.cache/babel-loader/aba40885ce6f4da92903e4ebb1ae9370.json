{"ast":null,"code":"import PathProxy from '../core/PathProxy';\nimport { cubicSubdivide } from '../core/curve';\nimport { defaults, assert, noop, clone } from '../core/util';\nimport { lerp } from '../core/vector';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\n\nfunction aroundEqual(a, b) {\n  return Math.abs(a - b) < 1e-5;\n}\n\nexport function pathToBezierCurves(path) {\n  var data = path.data;\n  var len = path.len();\n  var bezierArray = [];\n  var currentSubpath;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  function createNewSubpath(x, y) {\n    if (currentSubpath && currentSubpath.length > 2) {\n      bezierArray.push(currentSubpath);\n    }\n\n    currentSubpath = [x, y];\n  }\n\n  function addLine(x0, y0, x1, y1) {\n    if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n      currentSubpath.push(x0, y0, x1, y1, x1, y1);\n    }\n  }\n\n  function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n    var delta = Math.abs(endAngle - startAngle);\n    var len = Math.tan(delta / 4) * 4 / 3;\n    var dir = endAngle < startAngle ? -1 : 1;\n    var c1 = Math.cos(startAngle);\n    var s1 = Math.sin(startAngle);\n    var c2 = Math.cos(endAngle);\n    var s2 = Math.sin(endAngle);\n    var x1 = c1 * rx + cx;\n    var y1 = s1 * ry + cy;\n    var x4 = c2 * rx + cx;\n    var y4 = s2 * ry + cy;\n    var hx = rx * len * dir;\n    var hy = ry * len * dir;\n    currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n  }\n\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n\n  for (var i = 0; i < len;) {\n    var cmd = data[i++];\n    var isFirst = i === 1;\n\n    if (isFirst) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n\n      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n        currentSubpath = [x0, y0];\n      }\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        xi = x0 = data[i++];\n        yi = y0 = data[i++];\n        createNewSubpath(x0, y0);\n        break;\n\n      case CMD.L:\n        x1 = data[i++];\n        y1 = data[i++];\n        addLine(xi, yi, x1, y1);\n        xi = x1;\n        yi = y1;\n        break;\n\n      case CMD.C:\n        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n        break;\n\n      case CMD.Q:\n        x1 = data[i++];\n        y1 = data[i++];\n        x2 = data[i++];\n        y2 = data[i++];\n        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n        xi = x2;\n        yi = y2;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var startAngle = data[i++];\n        var endAngle = data[i++] + startAngle;\n        i += 1;\n        var anticlockwise = !data[i++];\n        x1 = Math.cos(startAngle) * rx + cx;\n        y1 = Math.sin(startAngle) * ry + cy;\n\n        if (isFirst) {\n          x0 = x1;\n          y0 = y1;\n          createNewSubpath(x0, y0);\n        } else {\n          addLine(xi, yi, x1, y1);\n        }\n\n        xi = Math.cos(endAngle) * rx + cx;\n        yi = Math.sin(endAngle) * ry + cy;\n        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n\n        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n          addArc(angle, nextAngle, cx, cy, rx, ry);\n        }\n\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        x1 = x0 + data[i++];\n        y1 = y0 + data[i++];\n        createNewSubpath(x1, y0);\n        addLine(x1, y0, x1, y1);\n        addLine(x1, y1, x0, y1);\n        addLine(x0, y1, x0, y0);\n        addLine(x0, y0, x1, y0);\n        break;\n\n      case CMD.Z:\n        currentSubpath && addLine(xi, yi, x0, y0);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (currentSubpath && currentSubpath.length > 2) {\n    bezierArray.push(currentSubpath);\n  }\n\n  return bezierArray;\n}\n\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n  var tmpSegX = [];\n  var tmpSegY = [];\n\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n\n    remained -= actualSubDivCount - 1;\n  }\n\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\n\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n\n  return newSubpath;\n}\n\nexport function alignBezierCurves(array1, array2) {\n  var _a;\n\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n\n  return [newArray1, newArray2];\n}\nexport function centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\n\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n\n  return bestOffset;\n}\n\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n\n  return newArr;\n}\n\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr_1 = [];\n    var len = fromSubpathBezier.length;\n\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr_1[k] = newX1;\n          tmpArr_1[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n\n          for (var m = 0; m < tmpArr_1.length; m++) {\n            newToSubpathBezier[m] = tmpArr_1[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n\n  return result;\n}\n\nexport function morphPath(fromPath, toPath, animationOpts) {\n  var fromPathProxy;\n  var toPathProxy;\n\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n\n  !fromPath.path && fromPath.createPathProxy();\n  fromPathProxy = fromPath.path;\n  fromPathProxy.beginPath();\n  fromPath.buildPath(fromPathProxy, fromPath.shape);\n  !toPath.path && toPath.createPathProxy();\n  toPathProxy = toPath.path;\n  toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n  toPathProxy.beginPath();\n\n  if (isIndividualMorphingPath(toPath)) {\n    toPath.__oldBuildPath(toPathProxy, toPath.shape);\n  } else {\n    toPath.buildPath(toPathProxy, toPath.shape);\n  }\n\n  var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)),\n      fromBezierCurves = _a[0],\n      toBezierCurves = _a[1];\n\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  becomeIndividualMorphingPath(toPath, morphingData, 0);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  toPath.animateTo({\n    __morphT: 1\n  }, defaults({\n    during: function (p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      restoreIndividualMorphingPath(toPath);\n      toPath.createPathProxy();\n      toPath.dirtyShape();\n      oldDone && oldDone();\n    },\n    aborted: function () {\n      oldAborted && oldAborted();\n    }\n  }, animationOpts));\n  return toPath;\n}\n\nfunction morphingPathBuildPath(path) {\n  var morphingData = this.__morphingData;\n  var t = this.__morphT;\n  var onet = 1 - t;\n  var newCp = [];\n\n  for (var i = 0; i < morphingData.length; i++) {\n    var item = morphingData[i];\n    var from = item.from;\n    var to = item.to;\n    var angle = item.rotation * t;\n    var fromCp = item.fromCp;\n    var toCp = item.toCp;\n    var sa = Math.sin(angle);\n    var ca = Math.cos(angle);\n    lerp(newCp, fromCp, toCp, t);\n\n    for (var m = 0; m < from.length; m += 2) {\n      var x0 = from[m];\n      var y0 = from[m + 1];\n      var x1 = to[m];\n      var y1 = to[m + 1];\n      var x = x0 * onet + x1 * t;\n      var y = y0 * onet + y1 * t;\n      tmpArr[m] = x * ca - y * sa + newCp[0];\n      tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n    }\n\n    for (var m = 0; m < from.length;) {\n      if (m === 0) {\n        path.moveTo(tmpArr[m++], tmpArr[m++]);\n      }\n\n      path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n    }\n  }\n}\n\n;\n\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n  if (isIndividualMorphingPath(path)) {\n    updateIndividualMorphingPath(path, morphingData, morphT);\n    return;\n  }\n\n  var morphingPath = path;\n  morphingPath.__oldBuildPath = morphingPath.buildPath;\n  morphingPath.buildPath = morphingPathBuildPath;\n  updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\n\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n  morphingPath.__morphingData = morphingData;\n  morphingPath.__morphT = morphT;\n}\n\nfunction restoreIndividualMorphingPath(path) {\n  if (isIndividualMorphingPath(path)) {\n    path.buildPath = path.__oldBuildPath;\n    path.__oldBuildPath = path.__morphingData = null;\n  }\n}\n\nfunction isIndividualMorphingPath(path) {\n  return path.__oldBuildPath != null;\n}\n\nexport function isCombiningPath(path) {\n  return !!path.__combiningSubList;\n}\nexport function isInAnyMorphing(path) {\n  return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexport function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n  var fromIndividuals = [];\n  var separateCount = 0;\n\n  for (var i = 0; i < fromPathList.length; i++) {\n    var fromPath = fromPathList[i];\n\n    if (isCombiningPath(fromPath)) {\n      var fromCombiningSubList = fromPath.__combiningSubList;\n\n      for (var j = 0; j < fromCombiningSubList.length; j++) {\n        fromIndividuals.push(fromCombiningSubList[j]);\n      }\n\n      separateCount += fromCombiningSubList.length;\n    } else {\n      fromIndividuals.push(fromPath);\n      separateCount++;\n    }\n  }\n\n  if (!separateCount) {\n    return;\n  }\n\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n  assert(toPathSplittedList.length === separateCount);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  var doneCount = 0;\n  var abortedCalled = false;\n  var morphAnimationOpts = defaults({\n    during: function (p) {\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      doneCount++;\n\n      if (doneCount === toPathSplittedList.length) {\n        restoreCombiningPath(toPath);\n        oldDone && oldDone();\n      }\n    },\n    aborted: function () {\n      if (!abortedCalled) {\n        abortedCalled = true;\n        oldAborted && oldAborted();\n      }\n    }\n  }, animationOpts);\n\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromIndividuals[i];\n    var to = toPathSplittedList[i];\n    copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n    morphPath(from, to, morphAnimationOpts);\n  }\n\n  becomeCombiningPath(toPath, toPathSplittedList);\n  return {\n    fromIndividuals: fromIndividuals,\n    toIndividuals: toPathSplittedList,\n    count: separateCount\n  };\n}\n\nfunction becomeCombiningPath(path, combiningSubList) {\n  if (isCombiningPath(path)) {\n    updateCombiningPathSubList(path, combiningSubList);\n    return;\n  }\n\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, combiningSubList);\n  combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n  combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n  combiningPath.addSelfToZr = combiningAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n  combiningPath.__oldBuildPath = combiningPath.buildPath;\n  combiningPath.buildPath = noop;\n  combiningPath.childrenRef = combiningChildrenRef;\n}\n\nfunction restoreCombiningPath(path) {\n  if (!isCombiningPath(path)) {\n    return;\n  }\n\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, null);\n  combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n  combiningPath.buildPath = combiningPath.__oldBuildPath;\n  combiningPath.childrenRef = combiningPath.__combiningSubList = combiningPath.__oldAddSelfToZr = combiningPath.__oldRemoveSelfFromZr = combiningPath.__oldBuildPath = null;\n}\n\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n  if (combiningPath.__combiningSubList !== combiningSubList) {\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n    combiningPath.__combiningSubList = combiningSubList;\n\n    if (combiningSubList) {\n      for (var i = 0; i < combiningSubList.length; i++) {\n        combiningSubList[i].parent = combiningPath;\n      }\n    }\n\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n  }\n}\n\nfunction combiningAddSelfToZr(zr) {\n  this.__oldAddSelfToZr(zr);\n\n  combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\n\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n  var combiningSubList = path.__combiningSubList;\n  var zr = path.__zr;\n\n  if (combiningSubList && zr) {\n    for (var i = 0; i < combiningSubList.length; i++) {\n      var child = combiningSubList[i];\n      child[method](zr);\n    }\n  }\n}\n\nfunction combiningRemoveSelfFromZr(zr) {\n  this.__oldRemoveSelfFromZr(zr);\n\n  var combiningSubList = this.__combiningSubList;\n\n  for (var i = 0; i < combiningSubList.length; i++) {\n    var child = combiningSubList[i];\n    child.removeSelfFromZr(zr);\n  }\n}\n\nfunction combiningChildrenRef() {\n  return this.__combiningSubList;\n}\n\nexport function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n  var toPathListLen = toPathList.length;\n  var fromPathList;\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var copyProps = false;\n\n  if (isCombiningPath(fromPath)) {\n    var fromCombiningSubList = fromPath.__combiningSubList;\n\n    if (fromCombiningSubList.length === toPathListLen) {\n      fromPathList = fromCombiningSubList;\n    } else {\n      fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n      copyProps = true;\n    }\n  } else {\n    fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n    copyProps = true;\n  }\n\n  assert(fromPathList.length === toPathListLen);\n\n  for (var i = 0; i < toPathListLen; i++) {\n    if (copyProps && copyPropsIfDivided) {\n      copyPropsIfDivided(fromPath, fromPathList[i], false);\n    }\n\n    morphPath(fromPathList[i], toPathList[i], animationOpts);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathListLen\n  };\n}\n\nfunction divideShape(path, separateCount, dividingMethod) {\n  return dividingMethod === 'duplicate' ? duplicateShape(path, separateCount) : splitShape(path, separateCount);\n}\n\nfunction splitShape(path, separateCount) {\n  var resultPaths = [];\n\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n\n  if (separateCount === 1) {\n    return duplicateShape(path, separateCount);\n  }\n\n  if (path instanceof Rect) {\n    var toPathShape = path.shape;\n    var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n    var propWH = PROP_WH[splitPropIdx];\n    var propXY = PROP_XY[splitPropIdx];\n    var subWH = toPathShape[propWH] / separateCount;\n    var xyCurr = toPathShape[propXY];\n\n    for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n      var subShape = {\n        x: toPathShape.x,\n        y: toPathShape.y,\n        width: toPathShape.width,\n        height: toPathShape.height\n      };\n      subShape[propXY] = xyCurr;\n      subShape[propWH] = i < separateCount - 1 ? subWH : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n      var splitted = new Rect({\n        shape: subShape\n      });\n      resultPaths.push(splitted);\n    }\n  } else if (path instanceof Sector) {\n    var toPathShape = path.shape;\n    var clockwise = toPathShape.clockwise;\n    var startAngle = toPathShape.startAngle;\n    var endAngle = toPathShape.endAngle;\n    var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n    var step = (endAngleNormalized - startAngle) / separateCount;\n    var angleCurr = startAngle;\n\n    for (var i = 0; i < separateCount; i++, angleCurr += step) {\n      var splitted = new Sector({\n        shape: {\n          cx: toPathShape.cx,\n          cy: toPathShape.cy,\n          r: toPathShape.r,\n          r0: toPathShape.r0,\n          clockwise: clockwise,\n          startAngle: angleCurr,\n          endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n        }\n      });\n      resultPaths.push(splitted);\n    }\n  } else {\n    return duplicateShape(path, separateCount);\n  }\n\n  return resultPaths;\n}\n\nfunction duplicateShape(path, separateCount) {\n  var resultPaths = [];\n\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n\n  var ctor = path.constructor;\n\n  for (var i = 0; i < separateCount; i++) {\n    var sub = new ctor({\n      shape: clone(path.shape)\n    });\n    resultPaths.push(sub);\n  }\n\n  return resultPaths;\n}\n\nfunction normalizeRadian(start, end, clockwise) {\n  return end + PI2 * Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2);\n}","map":{"version":3,"sources":["/home/kzj/project/finalize/B-S-/源码/前端/node_modules/zrender/lib/tool/morphPath.js"],"names":["PathProxy","cubicSubdivide","defaults","assert","noop","clone","lerp","Rect","Sector","CMD","PI2","Math","PI","PROP_XY","PROP_WH","tmpArr","aroundEqual","a","b","abs","pathToBezierCurves","path","data","len","bezierArray","currentSubpath","xi","yi","x0","y0","createNewSubpath","x","y","length","push","addLine","x1","y1","addArc","startAngle","endAngle","cx","cy","rx","ry","delta","tan","dir","c1","cos","s1","sin","c2","s2","x4","y4","hx","hy","x2","y2","i","cmd","isFirst","L","C","Q","M","A","anticlockwise","step","angle","nextAngle","max","min","R","Z","alignSubpath","subpath1","subpath2","len1","len2","shorterPath","shorterLen","diff","shorterBezierCount","eachCurveSubDivCount","ceil","newSubpath","remained","tmpSegX","tmpSegY","x3","y3","actualSubDivCount","k","p","createSubpath","lastSubpathSubpath","otherSubpath","lastX","lastY","alignBezierCurves","array1","array2","_a","lastSubpath1","lastSubpath2","newArray1","newArray2","newSubpath1","newSubpath2","centroid","array","signedArea","j","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","idx","dx","dy","reverse","newArr","findBestMorphingRotation","fromArr","toArr","searchAngleIteration","searchAngleRange","result","fromNeedsReverse","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr_1","sa","ca","newX1","newY1","m","i_1","from","to","rotation","morphPath","fromPath","toPath","animationOpts","fromPathProxy","toPathProxy","createPathProxy","beginPath","buildPath","shape","isIndividualMorphingPath","__oldBuildPath","fromBezierCurves","toBezierCurves","morphingData","becomeIndividualMorphingPath","oldDone","done","oldAborted","aborted","oldDuring","during","animateTo","__morphT","dirtyShape","restoreIndividualMorphingPath","morphingPathBuildPath","__morphingData","t","onet","newCp","item","moveTo","bezierCurveTo","morphT","updateIndividualMorphingPath","morphingPath","isCombiningPath","__combiningSubList","isInAnyMorphing","combine","fromPathList","copyPropsIfDivided","fromIndividuals","separateCount","fromCombiningSubList","dividingMethod","toPathSplittedList","divideShape","doneCount","abortedCalled","morphAnimationOpts","restoreCombiningPath","becomeCombiningPath","toIndividuals","count","combiningSubList","updateCombiningPathSubList","combiningPath","__oldAddSelfToZr","addSelfToZr","__oldRemoveSelfFromZr","removeSelfFromZr","combiningAddSelfToZr","combiningRemoveSelfFromZr","childrenRef","combiningChildrenRef","combiningPathSubListAddRemoveWithZr","parent","zr","method","__zr","child","separate","toPathList","toPathListLen","copyProps","duplicateShape","splitShape","resultPaths","toPathShape","splitPropIdx","height","width","propWH","propXY","subWH","xyCurr","subShape","splitted","clockwise","endAngleNormalized","normalizeRadian","angleCurr","r","r0","ctor","constructor","sub","start","end"],"mappings":"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","sourcesContent":["import PathProxy from '../core/PathProxy';\nimport { cubicSubdivide } from '../core/curve';\nimport { defaults, assert, noop, clone } from '../core/util';\nimport { lerp } from '../core/vector';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nexport function pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArray = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArray.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArray.push(currentSubpath);\n    }\n    return bezierArray;\n}\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    var tmpSegX = [];\n    var tmpSegY = [];\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr_1 = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr_1[k] = newX1;\n                    tmpArr_1[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr_1.length; m++) {\n                        newToSubpathBezier[m] = tmpArr_1[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    var fromPathProxy;\n    var toPathProxy;\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    !fromPath.path && fromPath.createPathProxy();\n    fromPathProxy = fromPath.path;\n    fromPathProxy.beginPath();\n    fromPath.buildPath(fromPathProxy, fromPath.shape);\n    !toPath.path && toPath.createPathProxy();\n    toPathProxy = toPath.path;\n    toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n    toPathProxy.beginPath();\n    if (isIndividualMorphingPath(toPath)) {\n        toPath.__oldBuildPath(toPathProxy, toPath.shape);\n    }\n    else {\n        toPath.buildPath(toPathProxy, toPath.shape);\n    }\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    becomeIndividualMorphingPath(toPath, morphingData, 0);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreIndividualMorphingPath(toPath);\n            toPath.createPathProxy();\n            toPath.dirtyShape();\n            oldDone && oldDone();\n        },\n        aborted: function () {\n            oldAborted && oldAborted();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction morphingPathBuildPath(path) {\n    var morphingData = this.__morphingData;\n    var t = this.__morphT;\n    var onet = 1 - t;\n    var newCp = [];\n    for (var i = 0; i < morphingData.length; i++) {\n        var item = morphingData[i];\n        var from = item.from;\n        var to = item.to;\n        var angle = item.rotation * t;\n        var fromCp = item.fromCp;\n        var toCp = item.toCp;\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        lerp(newCp, fromCp, toCp, t);\n        for (var m = 0; m < from.length; m += 2) {\n            var x0 = from[m];\n            var y0 = from[m + 1];\n            var x1 = to[m];\n            var y1 = to[m + 1];\n            var x = x0 * onet + x1 * t;\n            var y = y0 * onet + y1 * t;\n            tmpArr[m] = (x * ca - y * sa) + newCp[0];\n            tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n        }\n        for (var m = 0; m < from.length;) {\n            if (m === 0) {\n                path.moveTo(tmpArr[m++], tmpArr[m++]);\n            }\n            path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n        }\n    }\n}\n;\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n    if (isIndividualMorphingPath(path)) {\n        updateIndividualMorphingPath(path, morphingData, morphT);\n        return;\n    }\n    var morphingPath = path;\n    morphingPath.__oldBuildPath = morphingPath.buildPath;\n    morphingPath.buildPath = morphingPathBuildPath;\n    updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n    morphingPath.__morphingData = morphingData;\n    morphingPath.__morphT = morphT;\n}\nfunction restoreIndividualMorphingPath(path) {\n    if (isIndividualMorphingPath(path)) {\n        path.buildPath = path.__oldBuildPath;\n        path.__oldBuildPath = path.__morphingData = null;\n    }\n}\nfunction isIndividualMorphingPath(path) {\n    return path.__oldBuildPath != null;\n}\nexport function isCombiningPath(path) {\n    return !!path.__combiningSubList;\n}\nexport function isInAnyMorphing(path) {\n    return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexport function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n    var fromIndividuals = [];\n    var separateCount = 0;\n    for (var i = 0; i < fromPathList.length; i++) {\n        var fromPath = fromPathList[i];\n        if (isCombiningPath(fromPath)) {\n            var fromCombiningSubList = fromPath.__combiningSubList;\n            for (var j = 0; j < fromCombiningSubList.length; j++) {\n                fromIndividuals.push(fromCombiningSubList[j]);\n            }\n            separateCount += fromCombiningSubList.length;\n        }\n        else {\n            fromIndividuals.push(fromPath);\n            separateCount++;\n        }\n    }\n    if (!separateCount) {\n        return;\n    }\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n    assert(toPathSplittedList.length === separateCount);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    var doneCount = 0;\n    var abortedCalled = false;\n    var morphAnimationOpts = defaults({\n        during: function (p) {\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            doneCount++;\n            if (doneCount === toPathSplittedList.length) {\n                restoreCombiningPath(toPath);\n                oldDone && oldDone();\n            }\n        },\n        aborted: function () {\n            if (!abortedCalled) {\n                abortedCalled = true;\n                oldAborted && oldAborted();\n            }\n        }\n    }, animationOpts);\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromIndividuals[i];\n        var to = toPathSplittedList[i];\n        copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n        morphPath(from, to, morphAnimationOpts);\n    }\n    becomeCombiningPath(toPath, toPathSplittedList);\n    return {\n        fromIndividuals: fromIndividuals,\n        toIndividuals: toPathSplittedList,\n        count: separateCount\n    };\n}\nfunction becomeCombiningPath(path, combiningSubList) {\n    if (isCombiningPath(path)) {\n        updateCombiningPathSubList(path, combiningSubList);\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, combiningSubList);\n    combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n    combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n    combiningPath.addSelfToZr = combiningAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n    combiningPath.__oldBuildPath = combiningPath.buildPath;\n    combiningPath.buildPath = noop;\n    combiningPath.childrenRef = combiningChildrenRef;\n}\nfunction restoreCombiningPath(path) {\n    if (!isCombiningPath(path)) {\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, null);\n    combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n    combiningPath.buildPath = combiningPath.__oldBuildPath;\n    combiningPath.childrenRef =\n        combiningPath.__combiningSubList =\n            combiningPath.__oldAddSelfToZr =\n                combiningPath.__oldRemoveSelfFromZr =\n                    combiningPath.__oldBuildPath = null;\n}\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n    if (combiningPath.__combiningSubList !== combiningSubList) {\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n        combiningPath.__combiningSubList = combiningSubList;\n        if (combiningSubList) {\n            for (var i = 0; i < combiningSubList.length; i++) {\n                combiningSubList[i].parent = combiningPath;\n            }\n        }\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n    }\n}\nfunction combiningAddSelfToZr(zr) {\n    this.__oldAddSelfToZr(zr);\n    combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n    var combiningSubList = path.__combiningSubList;\n    var zr = path.__zr;\n    if (combiningSubList && zr) {\n        for (var i = 0; i < combiningSubList.length; i++) {\n            var child = combiningSubList[i];\n            child[method](zr);\n        }\n    }\n}\nfunction combiningRemoveSelfFromZr(zr) {\n    this.__oldRemoveSelfFromZr(zr);\n    var combiningSubList = this.__combiningSubList;\n    for (var i = 0; i < combiningSubList.length; i++) {\n        var child = combiningSubList[i];\n        child.removeSelfFromZr(zr);\n    }\n}\nfunction combiningChildrenRef() {\n    return this.__combiningSubList;\n}\nexport function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n    var toPathListLen = toPathList.length;\n    var fromPathList;\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var copyProps = false;\n    if (isCombiningPath(fromPath)) {\n        var fromCombiningSubList = fromPath.__combiningSubList;\n        if (fromCombiningSubList.length === toPathListLen) {\n            fromPathList = fromCombiningSubList;\n        }\n        else {\n            fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n            copyProps = true;\n        }\n    }\n    else {\n        fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n        copyProps = true;\n    }\n    assert(fromPathList.length === toPathListLen);\n    for (var i = 0; i < toPathListLen; i++) {\n        if (copyProps && copyPropsIfDivided) {\n            copyPropsIfDivided(fromPath, fromPathList[i], false);\n        }\n        morphPath(fromPathList[i], toPathList[i], animationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathListLen\n    };\n}\nfunction divideShape(path, separateCount, dividingMethod) {\n    return dividingMethod === 'duplicate'\n        ? duplicateShape(path, separateCount)\n        : splitShape(path, separateCount);\n}\nfunction splitShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    if (separateCount === 1) {\n        return duplicateShape(path, separateCount);\n    }\n    if (path instanceof Rect) {\n        var toPathShape = path.shape;\n        var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n        var propWH = PROP_WH[splitPropIdx];\n        var propXY = PROP_XY[splitPropIdx];\n        var subWH = toPathShape[propWH] / separateCount;\n        var xyCurr = toPathShape[propXY];\n        for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n            var subShape = {\n                x: toPathShape.x,\n                y: toPathShape.y,\n                width: toPathShape.width,\n                height: toPathShape.height\n            };\n            subShape[propXY] = xyCurr;\n            subShape[propWH] = i < separateCount - 1\n                ? subWH\n                : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n            var splitted = new Rect({ shape: subShape });\n            resultPaths.push(splitted);\n        }\n    }\n    else if (path instanceof Sector) {\n        var toPathShape = path.shape;\n        var clockwise = toPathShape.clockwise;\n        var startAngle = toPathShape.startAngle;\n        var endAngle = toPathShape.endAngle;\n        var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n        var step = (endAngleNormalized - startAngle) / separateCount;\n        var angleCurr = startAngle;\n        for (var i = 0; i < separateCount; i++, angleCurr += step) {\n            var splitted = new Sector({\n                shape: {\n                    cx: toPathShape.cx,\n                    cy: toPathShape.cy,\n                    r: toPathShape.r,\n                    r0: toPathShape.r0,\n                    clockwise: clockwise,\n                    startAngle: angleCurr,\n                    endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n                }\n            });\n            resultPaths.push(splitted);\n        }\n    }\n    else {\n        return duplicateShape(path, separateCount);\n    }\n    return resultPaths;\n}\nfunction duplicateShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    var ctor = path.constructor;\n    for (var i = 0; i < separateCount; i++) {\n        var sub = new ctor({\n            shape: clone(path.shape)\n        });\n        resultPaths.push(sub);\n    }\n    return resultPaths;\n}\nfunction normalizeRadian(start, end, clockwise) {\n    return end + PI2 * (Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2));\n}\n"]},"metadata":{},"sourceType":"module"}