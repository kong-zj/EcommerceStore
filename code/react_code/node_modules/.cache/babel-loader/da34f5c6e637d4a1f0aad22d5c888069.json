{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, createHashMap } from 'zrender/lib/core/util';\nimport mapDataStorage from './mapDataStorage';\nimport geoJSONLoader from './geoJSONLoader';\nimport geoSVGLoader from './geoSVGLoader';\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nvar loaders = {\n  geoJSON: geoJSONLoader,\n  svg: geoSVGLoader\n};\nexport default {\n  load: function (mapName, nameMap, nameProperty) {\n    var regions = [];\n    var regionsMap = createHashMap();\n    var nameCoordMap = createHashMap();\n    var boundingRect;\n    var mapRecords = retrieveMap(mapName);\n    each(mapRecords, function (record) {\n      var singleSource = loaders[record.type].load(mapName, record, nameProperty);\n      each(singleSource.regions, function (region) {\n        var regionName = region.name; // Try use the alias in geoNameMap\n\n        if (nameMap && nameMap.hasOwnProperty(regionName)) {\n          region = region.cloneShallow(regionName = nameMap[regionName]);\n        }\n\n        regions.push(region);\n        regionsMap.set(regionName, region);\n        nameCoordMap.set(regionName, region.center);\n      });\n      var rect = singleSource.boundingRect;\n\n      if (rect) {\n        boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();\n      }\n    });\n    return {\n      regions: regions,\n      regionsMap: regionsMap,\n      nameCoordMap: nameCoordMap,\n      // FIXME Always return new ?\n      boundingRect: boundingRect || new BoundingRect(0, 0, 0, 0)\n    };\n  },\n\n  /**\n   * @param hostKey For cache.\n   * @return Roots.\n   */\n  makeGraphic: function (mapName, hostKey) {\n    var mapRecords = retrieveMap(mapName);\n    var results = [];\n    each(mapRecords, function (record) {\n      var method = loaders[record.type].makeGraphic;\n      method && results.push(method(mapName, record, hostKey));\n    });\n    return results;\n  },\n\n  /**\n   * @param hostKey For cache.\n   */\n  removeGraphic: function (mapName, hostKey) {\n    var mapRecords = retrieveMap(mapName);\n    each(mapRecords, function (record) {\n      var method = loaders[record.type].makeGraphic;\n      method && method(mapName, record, hostKey);\n    });\n  }\n};\n\nfunction mapNotExistsError(mapName) {\n  if (process.env.NODE_ENV !== 'production') {\n    console.error('Map ' + mapName + ' not exists. The GeoJSON of the map must be provided.');\n  }\n}\n\nfunction retrieveMap(mapName) {\n  var mapRecords = mapDataStorage.retrieveMap(mapName) || [];\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!mapRecords.length) {\n      mapNotExistsError(mapName);\n    }\n  }\n\n  return mapRecords;\n}","map":{"version":3,"sources":["/home/kzj/project/finalize/B-S-/源码/前端/node_modules/echarts/lib/coord/geo/geoSourceManager.js"],"names":["each","createHashMap","mapDataStorage","geoJSONLoader","geoSVGLoader","BoundingRect","loaders","geoJSON","svg","load","mapName","nameMap","nameProperty","regions","regionsMap","nameCoordMap","boundingRect","mapRecords","retrieveMap","record","singleSource","type","region","regionName","name","hasOwnProperty","cloneShallow","push","set","center","rect","union","clone","makeGraphic","hostKey","results","method","removeGraphic","mapNotExistsError","process","env","NODE_ENV","console","error","length"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, createHashMap } from 'zrender/lib/core/util';\nimport mapDataStorage from './mapDataStorage';\nimport geoJSONLoader from './geoJSONLoader';\nimport geoSVGLoader from './geoSVGLoader';\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nvar loaders = {\n  geoJSON: geoJSONLoader,\n  svg: geoSVGLoader\n};\nexport default {\n  load: function (mapName, nameMap, nameProperty) {\n    var regions = [];\n    var regionsMap = createHashMap();\n    var nameCoordMap = createHashMap();\n    var boundingRect;\n    var mapRecords = retrieveMap(mapName);\n    each(mapRecords, function (record) {\n      var singleSource = loaders[record.type].load(mapName, record, nameProperty);\n      each(singleSource.regions, function (region) {\n        var regionName = region.name; // Try use the alias in geoNameMap\n\n        if (nameMap && nameMap.hasOwnProperty(regionName)) {\n          region = region.cloneShallow(regionName = nameMap[regionName]);\n        }\n\n        regions.push(region);\n        regionsMap.set(regionName, region);\n        nameCoordMap.set(regionName, region.center);\n      });\n      var rect = singleSource.boundingRect;\n\n      if (rect) {\n        boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();\n      }\n    });\n    return {\n      regions: regions,\n      regionsMap: regionsMap,\n      nameCoordMap: nameCoordMap,\n      // FIXME Always return new ?\n      boundingRect: boundingRect || new BoundingRect(0, 0, 0, 0)\n    };\n  },\n\n  /**\n   * @param hostKey For cache.\n   * @return Roots.\n   */\n  makeGraphic: function (mapName, hostKey) {\n    var mapRecords = retrieveMap(mapName);\n    var results = [];\n    each(mapRecords, function (record) {\n      var method = loaders[record.type].makeGraphic;\n      method && results.push(method(mapName, record, hostKey));\n    });\n    return results;\n  },\n\n  /**\n   * @param hostKey For cache.\n   */\n  removeGraphic: function (mapName, hostKey) {\n    var mapRecords = retrieveMap(mapName);\n    each(mapRecords, function (record) {\n      var method = loaders[record.type].makeGraphic;\n      method && method(mapName, record, hostKey);\n    });\n  }\n};\n\nfunction mapNotExistsError(mapName) {\n  if (process.env.NODE_ENV !== 'production') {\n    console.error('Map ' + mapName + ' not exists. The GeoJSON of the map must be provided.');\n  }\n}\n\nfunction retrieveMap(mapName) {\n  var mapRecords = mapDataStorage.retrieveMap(mapName) || [];\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!mapRecords.length) {\n      mapNotExistsError(mapName);\n    }\n  }\n\n  return mapRecords;\n}"]},"metadata":{},"sourceType":"module"}