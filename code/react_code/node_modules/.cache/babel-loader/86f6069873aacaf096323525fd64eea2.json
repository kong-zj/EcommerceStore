{"ast":null,"code":"var tokenize = require('./tokenize');\n\nvar MAX_RANGE = 0x1FFFFFFF; // \"Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared \"packed\".\"\n// https://developers.google.com/protocol-buffers/docs/encoding#optional\n\nvar PACKABLE_TYPES = [// varint wire types\n'int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'bool', // + ENUMS\n// 64-bit wire types\n'fixed64', 'sfixed64', 'double', // 32-bit wire types\n'fixed32', 'sfixed32', 'float'];\n\nvar onfieldoptionvalue = function (tokens) {\n  var value = tokens.shift();\n\n  if (value !== '{') {\n    return value;\n  }\n\n  value = {};\n  var field = '';\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '}':\n        tokens.shift();\n        return value;\n\n      case ':':\n        tokens.shift();\n        value[field] = onfieldoptionvalue(tokens);\n        break;\n\n      default:\n        field = tokens.shift();\n    }\n  }\n};\n\nvar onfieldoptions = function (tokens) {\n  var opts = {};\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '[':\n      case ',':\n        {\n          tokens.shift();\n          var name = tokens.shift();\n\n          if (name === '(') {\n            // handling [(A) = B]\n            name = tokens.shift();\n            tokens.shift(); // remove the end of bracket\n          }\n\n          var field = [];\n\n          if (tokens[0][0] === '.') {\n            field = tokens[0].substr(1).split('.');\n            tokens.shift();\n          }\n\n          if (tokens[0] !== '=') throw new Error('Unexpected token in field options: ' + tokens[0]);\n          tokens.shift();\n          if (tokens[0] === ']') throw new Error('Unexpected ] in field option'); // for option (A).b.c\n          // path will be ['A', 'b'] and lastFieldName 'c'\n\n          var path = [name].concat(field);\n          var lastFieldName = path.pop(); // opt references opts.A.b\n\n          var opt = path.reduce(function (opt, n, index) {\n            if (opt[n] == null) {\n              opt[n] = {};\n            }\n\n            return opt[n];\n          }, opts); // now set opt['c'] that references opts.A.b['c']\n\n          opt[lastFieldName] = onfieldoptionvalue(tokens);\n          break;\n        }\n\n      case ']':\n        tokens.shift();\n        return opts;\n\n      default:\n        throw new Error('Unexpected token in field options: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for field options');\n};\n\nvar onfield = function (tokens) {\n  var field = {\n    name: null,\n    type: null,\n    tag: -1,\n    map: null,\n    oneof: null,\n    required: false,\n    repeated: false,\n    options: {}\n  };\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '=':\n        tokens.shift();\n        field.tag = Number(tokens.shift());\n        break;\n\n      case 'map':\n        field.type = 'map';\n        field.map = {\n          from: null,\n          to: null\n        };\n        tokens.shift();\n        if (tokens[0] !== '<') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.map.from = tokens.shift();\n        if (tokens[0] !== ',') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.map.to = tokens.shift();\n        if (tokens[0] !== '>') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.name = tokens.shift();\n        break;\n\n      case 'repeated':\n      case 'required':\n      case 'optional':\n        var t = tokens.shift();\n        field.required = t === 'required';\n        field.repeated = t === 'repeated';\n        field.type = tokens.shift();\n        field.name = tokens.shift();\n        break;\n\n      case '[':\n        field.options = onfieldoptions(tokens);\n        break;\n\n      case ';':\n        if (field.name === null) throw new Error('Missing field name');\n        if (field.type === null) throw new Error('Missing type in message field: ' + field.name);\n        if (field.tag === -1) throw new Error('Missing tag number in message field: ' + field.name);\n        tokens.shift();\n        return field;\n\n      default:\n        throw new Error('Unexpected token in message field: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No ; found for message field');\n};\n\nvar onmessagebody = function (tokens) {\n  var body = {\n    enums: [],\n    options: {},\n    messages: [],\n    fields: [],\n    extends: [],\n    extensions: null\n  };\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'map':\n      case 'repeated':\n      case 'optional':\n      case 'required':\n        body.fields.push(onfield(tokens));\n        break;\n\n      case 'enum':\n        body.enums.push(onenum(tokens));\n        break;\n\n      case 'message':\n        body.messages.push(onmessage(tokens));\n        break;\n\n      case 'extensions':\n        body.extensions = onextensions(tokens);\n        break;\n\n      case 'oneof':\n        tokens.shift();\n        var name = tokens.shift();\n        if (tokens[0] !== '{') throw new Error('Unexpected token in oneof: ' + tokens[0]);\n        tokens.shift();\n\n        while (tokens[0] !== '}') {\n          tokens.unshift('optional');\n          var field = onfield(tokens);\n          field.oneof = name;\n          body.fields.push(field);\n        }\n\n        tokens.shift();\n        break;\n\n      case 'extend':\n        body.extends.push(onextend(tokens));\n        break;\n\n      case ';':\n        tokens.shift();\n        break;\n\n      case 'reserved':\n        tokens.shift();\n\n        while (tokens[0] !== ';') {\n          tokens.shift();\n        }\n\n        break;\n\n      case 'option':\n        var opt = onoption(tokens);\n        if (body.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n        body.options[opt.name] = opt.value;\n        break;\n\n      default:\n        // proto3 does not require the use of optional/required, assumed as optional\n        // \"singular: a well-formed message can have zero or one of this field (but not more than one).\"\n        // https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules\n        tokens.unshift('optional');\n        body.fields.push(onfield(tokens));\n    }\n  }\n\n  return body;\n};\n\nvar onextend = function (tokens) {\n  var out = {\n    name: tokens[1],\n    message: onmessage(tokens)\n  };\n  return out;\n};\n\nvar onextensions = function (tokens) {\n  tokens.shift();\n  var from = Number(tokens.shift());\n  if (isNaN(from)) throw new Error('Invalid from in extensions definition');\n  if (tokens.shift() !== 'to') throw new Error(\"Expected keyword 'to' in extensions definition\");\n  var to = tokens.shift();\n  if (to === 'max') to = MAX_RANGE;\n  to = Number(to);\n  if (isNaN(to)) throw new Error('Invalid to in extensions definition');\n  if (tokens.shift() !== ';') throw new Error('Missing ; in extensions definition');\n  return {\n    from: from,\n    to: to\n  };\n};\n\nvar onmessage = function (tokens) {\n  tokens.shift();\n  var lvl = 1;\n  var body = [];\n  var msg = {\n    name: tokens.shift(),\n    options: {},\n    enums: [],\n    extends: [],\n    messages: [],\n    fields: []\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '{') lvl++;else if (tokens[0] === '}') lvl--;\n\n    if (!lvl) {\n      tokens.shift();\n      body = onmessagebody(body);\n      msg.enums = body.enums;\n      msg.messages = body.messages;\n      msg.fields = body.fields;\n      msg.extends = body.extends;\n      msg.extensions = body.extensions;\n      msg.options = body.options;\n      return msg;\n    }\n\n    body.push(tokens.shift());\n  }\n\n  if (lvl) throw new Error('No closing tag for message');\n};\n\nvar onpackagename = function (tokens) {\n  tokens.shift();\n  var name = tokens.shift();\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0]);\n  tokens.shift();\n  return name;\n};\n\nvar onsyntaxversion = function (tokens) {\n  tokens.shift();\n  if (tokens[0] !== '=') throw new Error('Expected = but found ' + tokens[0]);\n  tokens.shift();\n  var version = tokens.shift();\n\n  switch (version) {\n    case '\"proto2\"':\n      version = 2;\n      break;\n\n    case '\"proto3\"':\n      version = 3;\n      break;\n\n    default:\n      throw new Error('Expected protobuf syntax version but found ' + version);\n  }\n\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0]);\n  tokens.shift();\n  return version;\n};\n\nvar onenumvalue = function (tokens) {\n  if (tokens.length < 4) throw new Error('Invalid enum value: ' + tokens.slice(0, 3).join(' '));\n  if (tokens[1] !== '=') throw new Error('Expected = but found ' + tokens[1]);\n  if (tokens[3] !== ';' && tokens[3] !== '[') throw new Error('Expected ; or [ but found ' + tokens[1]);\n  var name = tokens.shift();\n  tokens.shift();\n  var val = {\n    value: null,\n    options: {}\n  };\n  val.value = Number(tokens.shift());\n\n  if (tokens[0] === '[') {\n    val.options = onfieldoptions(tokens);\n  }\n\n  tokens.shift(); // expecting the semicolon here\n\n  return {\n    name: name,\n    val: val\n  };\n};\n\nvar onenum = function (tokens) {\n  tokens.shift();\n  var options = {};\n  var e = {\n    name: tokens.shift(),\n    values: {},\n    options: {}\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return e;\n    }\n\n    if (tokens[0] === 'option') {\n      options = onoption(tokens);\n      e.options[options.name] = options.value;\n      continue;\n    }\n\n    var val = onenumvalue(tokens);\n    e.values[val.name] = val.val;\n  }\n\n  throw new Error('No closing tag for enum');\n};\n\nvar onoption = function (tokens) {\n  var name = null;\n  var value = null;\n\n  var parse = function (value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value.replace(/^\"+|\"+$/gm, '');\n  };\n\n  while (tokens.length) {\n    if (tokens[0] === ';') {\n      tokens.shift();\n      return {\n        name: name,\n        value: value\n      };\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        tokens.shift();\n        var hasBracket = tokens[0] === '(';\n        if (hasBracket) tokens.shift();\n        name = tokens.shift();\n\n        if (hasBracket) {\n          if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n          tokens.shift();\n        }\n\n        if (tokens[0][0] === '.') {\n          name += tokens.shift();\n        }\n\n        break;\n\n      case '=':\n        tokens.shift();\n        if (name === null) throw new Error('Expected key for option with value: ' + tokens[0]);\n        value = parse(tokens.shift());\n\n        if (name === 'optimize_for' && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {\n          throw new Error('Unexpected value for option optimize_for: ' + value);\n        } else if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens);\n        }\n\n        break;\n\n      default:\n        throw new Error('Unexpected token in option: ' + tokens[0]);\n    }\n  }\n};\n\nvar onoptionMap = function (tokens) {\n  var parse = function (value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value.replace(/^\"+|\"+$/gm, '');\n  };\n\n  var map = {};\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift();\n      return map;\n    }\n\n    var hasBracket = tokens[0] === '(';\n    if (hasBracket) tokens.shift();\n    var key = tokens.shift();\n\n    if (hasBracket) {\n      if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n      tokens.shift();\n    }\n\n    var value = null;\n\n    switch (tokens[0]) {\n      case ':':\n        if (map[key] !== undefined) throw new Error('Duplicate option map key ' + key);\n        tokens.shift();\n        value = parse(tokens.shift());\n\n        if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens);\n        }\n\n        map[key] = value;\n\n        if (tokens[0] === ';') {\n          tokens.shift();\n        }\n\n        break;\n\n      case '{':\n        tokens.shift();\n        value = onoptionMap(tokens);\n        if (map[key] === undefined) map[key] = [];\n        if (!Array.isArray(map[key])) throw new Error('Duplicate option map key ' + key);\n        map[key].push(value);\n        break;\n\n      default:\n        throw new Error('Unexpected token in option map: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for option map');\n};\n\nvar onimport = function (tokens) {\n  tokens.shift();\n  var file = tokens.shift().replace(/^\"+|\"+$/gm, '');\n  if (tokens[0] !== ';') throw new Error('Unexpected token: ' + tokens[0] + '. Expected \";\"');\n  tokens.shift();\n  return file;\n};\n\nvar onservice = function (tokens) {\n  tokens.shift();\n  var service = {\n    name: tokens.shift(),\n    methods: [],\n    options: {}\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return service;\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        var opt = onoption(tokens);\n        if (service.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n        service.options[opt.name] = opt.value;\n        break;\n\n      case 'rpc':\n        service.methods.push(onrpc(tokens));\n        break;\n\n      default:\n        throw new Error('Unexpected token in service: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for service');\n};\n\nvar onrpc = function (tokens) {\n  tokens.shift();\n  var rpc = {\n    name: tokens.shift(),\n    input_type: null,\n    output_type: null,\n    client_streaming: false,\n    server_streaming: false,\n    options: {}\n  };\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === 'stream') {\n    tokens.shift();\n    rpc.client_streaming = true;\n  }\n\n  rpc.input_type = tokens.shift();\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n  tokens.shift();\n  if (tokens[0] !== 'returns') throw new Error('Expected returns but found ' + tokens[0]);\n  tokens.shift();\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === 'stream') {\n    tokens.shift();\n    rpc.server_streaming = true;\n  }\n\n  rpc.output_type = tokens.shift();\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === ';') {\n    tokens.shift();\n    return rpc;\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return rpc;\n    }\n\n    if (tokens[0] === 'option') {\n      var opt = onoption(tokens);\n      if (rpc.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n      rpc.options[opt.name] = opt.value;\n    } else {\n      throw new Error('Unexpected token in rpc options: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for rpc');\n};\n\nvar parse = function (buf) {\n  var tokens = tokenize(buf.toString()); // check for isolated strings in tokens by looking for opening quote\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (/^(\"|')([^'\"]*)$/.test(tokens[i])) {\n      var j;\n\n      if (tokens[i].length === 1) {\n        j = i + 1;\n      } else {\n        j = i;\n      } // look ahead for the closing quote and collapse all\n      // in-between tokens into a single token\n\n\n      for (j; j < tokens.length; j++) {\n        if (/^[^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*(\"|')$/.test(tokens[j])) {\n          tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join('')).concat(tokens.slice(j + 1));\n          break;\n        }\n      }\n    }\n  }\n\n  var schema = {\n    syntax: 3,\n    package: null,\n    imports: [],\n    enums: [],\n    messages: [],\n    options: {},\n    extends: []\n  };\n  var firstline = true;\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'package':\n        schema.package = onpackagename(tokens);\n        break;\n\n      case 'syntax':\n        if (!firstline) throw new Error('Protobuf syntax version should be first thing in file');\n        schema.syntax = onsyntaxversion(tokens);\n        break;\n\n      case 'message':\n        schema.messages.push(onmessage(tokens));\n        break;\n\n      case 'enum':\n        schema.enums.push(onenum(tokens));\n        break;\n\n      case 'option':\n        var opt = onoption(tokens);\n        if (schema.options[opt.name]) throw new Error('Duplicate option ' + opt.name);\n        schema.options[opt.name] = opt.value;\n        break;\n\n      case 'import':\n        schema.imports.push(onimport(tokens));\n        break;\n\n      case 'extend':\n        schema.extends.push(onextend(tokens));\n        break;\n\n      case 'service':\n        if (!schema.services) schema.services = [];\n        schema.services.push(onservice(tokens));\n        break;\n\n      default:\n        throw new Error('Unexpected token: ' + tokens[0]);\n    }\n\n    firstline = false;\n  } // now iterate over messages and propagate extends\n\n\n  schema.extends.forEach(function (ext) {\n    schema.messages.forEach(function (msg) {\n      if (msg.name === ext.name) {\n        ext.message.fields.forEach(function (field) {\n          if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {\n            throw new Error(msg.name + ' does not declare ' + field.tag + ' as an extension number');\n          }\n\n          msg.fields.push(field);\n        });\n      }\n    });\n  });\n  schema.messages.forEach(function (msg) {\n    msg.fields.forEach(function (field) {\n      var fieldSplit;\n      var messageName;\n      var nestedEnumName;\n      var message;\n\n      function enumNameIsFieldType(en) {\n        return en.name === field.type;\n      }\n\n      function enumNameIsNestedEnumName(en) {\n        return en.name === nestedEnumName;\n      }\n\n      if (field.options && field.options.packed === 'true') {\n        if (PACKABLE_TYPES.indexOf(field.type) === -1) {\n          // let's see if it's an enum\n          if (field.type.indexOf('.') === -1) {\n            if (msg.enums && msg.enums.some(enumNameIsFieldType)) {\n              return;\n            }\n          } else {\n            fieldSplit = field.type.split('.');\n\n            if (fieldSplit.length > 2) {\n              throw new Error('what is this?');\n            }\n\n            messageName = fieldSplit[0];\n            nestedEnumName = fieldSplit[1];\n            schema.messages.some(function (msg) {\n              if (msg.name === messageName) {\n                message = msg;\n                return msg;\n              }\n            });\n\n            if (message && message.enums && message.enums.some(enumNameIsNestedEnumName)) {\n              return;\n            }\n          }\n\n          throw new Error('Fields of type ' + field.type + ' cannot be declared [packed=true]. ' + 'Only repeated fields of primitive numeric types (types which use ' + 'the varint, 32-bit, or 64-bit wire types) can be declared \"packed\". ' + 'See https://developers.google.com/protocol-buffers/docs/encoding#optional');\n        }\n      }\n    });\n  });\n  return schema;\n};\n\nmodule.exports = parse;","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/protocol-buffers-schema/parse.js"],"names":["tokenize","require","MAX_RANGE","PACKABLE_TYPES","onfieldoptionvalue","tokens","value","shift","field","length","onfieldoptions","opts","name","substr","split","Error","path","concat","lastFieldName","pop","opt","reduce","n","index","onfield","type","tag","map","oneof","required","repeated","options","Number","from","to","t","onmessagebody","body","enums","messages","fields","extends","extensions","push","onenum","onmessage","onextensions","unshift","onextend","onoption","undefined","out","message","isNaN","lvl","msg","onpackagename","onsyntaxversion","version","onenumvalue","slice","join","val","e","values","parse","replace","hasBracket","test","onoptionMap","key","Array","isArray","onimport","file","onservice","service","methods","onrpc","rpc","input_type","output_type","client_streaming","server_streaming","buf","toString","i","j","schema","syntax","package","imports","firstline","services","forEach","ext","fieldSplit","messageName","nestedEnumName","enumNameIsFieldType","en","enumNameIsNestedEnumName","packed","indexOf","some","module","exports"],"mappings":"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","sourcesContent":["var tokenize = require('./tokenize')\nvar MAX_RANGE = 0x1FFFFFFF\n\n// \"Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared \"packed\".\"\n// https://developers.google.com/protocol-buffers/docs/encoding#optional\nvar PACKABLE_TYPES = [\n  // varint wire types\n  'int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'bool',\n  // + ENUMS\n  // 64-bit wire types\n  'fixed64', 'sfixed64', 'double',\n  // 32-bit wire types\n  'fixed32', 'sfixed32', 'float'\n]\n\nvar onfieldoptionvalue = function (tokens) {\n  var value = tokens.shift()\n  if (value !== '{') {\n    return value\n  }\n  value = {}\n  var field = ''\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '}':\n        tokens.shift()\n        return value\n      case ':':\n        tokens.shift()\n        value[field] = onfieldoptionvalue(tokens)\n        break\n      default:\n        field = tokens.shift()\n    }\n  }\n}\n\nvar onfieldoptions = function (tokens) {\n  var opts = {}\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '[':\n      case ',': {\n        tokens.shift()\n        var name = tokens.shift()\n        if (name === '(') { // handling [(A) = B]\n          name = tokens.shift()\n          tokens.shift() // remove the end of bracket\n        }\n        var field = []\n        if (tokens[0][0] === '.') {\n          field = tokens[0].substr(1).split('.')\n          tokens.shift()\n        }\n        if (tokens[0] !== '=') throw new Error('Unexpected token in field options: ' + tokens[0])\n        tokens.shift()\n        if (tokens[0] === ']') throw new Error('Unexpected ] in field option')\n\n        // for option (A).b.c\n        // path will be ['A', 'b'] and lastFieldName 'c'\n        var path = [name].concat(field)\n        var lastFieldName = path.pop()\n\n        // opt references opts.A.b\n        var opt = path.reduce(function (opt, n, index) {\n          if (opt[n] == null) {\n            opt[n] = {}\n          }\n          return opt[n]\n        }, opts)\n\n        // now set opt['c'] that references opts.A.b['c']\n        opt[lastFieldName] = onfieldoptionvalue(tokens)\n        break\n      }\n      case ']':\n        tokens.shift()\n        return opts\n\n      default:\n        throw new Error('Unexpected token in field options: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for field options')\n}\n\nvar onfield = function (tokens) {\n  var field = {\n    name: null,\n    type: null,\n    tag: -1,\n    map: null,\n    oneof: null,\n    required: false,\n    repeated: false,\n    options: {}\n  }\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '=':\n        tokens.shift()\n        field.tag = Number(tokens.shift())\n        break\n\n      case 'map':\n        field.type = 'map'\n        field.map = { from: null, to: null }\n        tokens.shift()\n        if (tokens[0] !== '<') throw new Error('Unexpected token in map type: ' + tokens[0])\n        tokens.shift()\n        field.map.from = tokens.shift()\n        if (tokens[0] !== ',') throw new Error('Unexpected token in map type: ' + tokens[0])\n        tokens.shift()\n        field.map.to = tokens.shift()\n        if (tokens[0] !== '>') throw new Error('Unexpected token in map type: ' + tokens[0])\n        tokens.shift()\n        field.name = tokens.shift()\n        break\n\n      case 'repeated':\n      case 'required':\n      case 'optional':\n        var t = tokens.shift()\n        field.required = t === 'required'\n        field.repeated = t === 'repeated'\n        field.type = tokens.shift()\n        field.name = tokens.shift()\n        break\n\n      case '[':\n        field.options = onfieldoptions(tokens)\n        break\n\n      case ';':\n        if (field.name === null) throw new Error('Missing field name')\n        if (field.type === null) throw new Error('Missing type in message field: ' + field.name)\n        if (field.tag === -1) throw new Error('Missing tag number in message field: ' + field.name)\n        tokens.shift()\n        return field\n\n      default:\n        throw new Error('Unexpected token in message field: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No ; found for message field')\n}\n\nvar onmessagebody = function (tokens) {\n  var body = {\n    enums: [],\n    options: {},\n    messages: [],\n    fields: [],\n    extends: [],\n    extensions: null\n  }\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'map':\n      case 'repeated':\n      case 'optional':\n      case 'required':\n        body.fields.push(onfield(tokens))\n        break\n\n      case 'enum':\n        body.enums.push(onenum(tokens))\n        break\n\n      case 'message':\n        body.messages.push(onmessage(tokens))\n        break\n\n      case 'extensions':\n        body.extensions = onextensions(tokens)\n        break\n\n      case 'oneof':\n        tokens.shift()\n        var name = tokens.shift()\n        if (tokens[0] !== '{') throw new Error('Unexpected token in oneof: ' + tokens[0])\n        tokens.shift()\n        while (tokens[0] !== '}') {\n          tokens.unshift('optional')\n          var field = onfield(tokens)\n          field.oneof = name\n          body.fields.push(field)\n        }\n        tokens.shift()\n        break\n\n      case 'extend':\n        body.extends.push(onextend(tokens))\n        break\n\n      case ';':\n        tokens.shift()\n        break\n\n      case 'reserved':\n        tokens.shift()\n        while (tokens[0] !== ';') {\n          tokens.shift()\n        }\n        break\n\n      case 'option':\n        var opt = onoption(tokens)\n        if (body.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)\n        body.options[opt.name] = opt.value\n        break\n\n      default:\n        // proto3 does not require the use of optional/required, assumed as optional\n        // \"singular: a well-formed message can have zero or one of this field (but not more than one).\"\n        // https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules\n        tokens.unshift('optional')\n        body.fields.push(onfield(tokens))\n    }\n  }\n\n  return body\n}\n\nvar onextend = function (tokens) {\n  var out = {\n    name: tokens[1],\n    message: onmessage(tokens)\n  }\n  return out\n}\n\nvar onextensions = function (tokens) {\n  tokens.shift()\n  var from = Number(tokens.shift())\n  if (isNaN(from)) throw new Error('Invalid from in extensions definition')\n  if (tokens.shift() !== 'to') throw new Error(\"Expected keyword 'to' in extensions definition\")\n  var to = tokens.shift()\n  if (to === 'max') to = MAX_RANGE\n  to = Number(to)\n  if (isNaN(to)) throw new Error('Invalid to in extensions definition')\n  if (tokens.shift() !== ';') throw new Error('Missing ; in extensions definition')\n  return { from: from, to: to }\n}\nvar onmessage = function (tokens) {\n  tokens.shift()\n\n  var lvl = 1\n  var body = []\n  var msg = {\n    name: tokens.shift(),\n    options: {},\n    enums: [],\n    extends: [],\n    messages: [],\n    fields: []\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '{') lvl++\n    else if (tokens[0] === '}') lvl--\n\n    if (!lvl) {\n      tokens.shift()\n      body = onmessagebody(body)\n      msg.enums = body.enums\n      msg.messages = body.messages\n      msg.fields = body.fields\n      msg.extends = body.extends\n      msg.extensions = body.extensions\n      msg.options = body.options\n      return msg\n    }\n\n    body.push(tokens.shift())\n  }\n\n  if (lvl) throw new Error('No closing tag for message')\n}\n\nvar onpackagename = function (tokens) {\n  tokens.shift()\n  var name = tokens.shift()\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])\n  tokens.shift()\n  return name\n}\n\nvar onsyntaxversion = function (tokens) {\n  tokens.shift()\n\n  if (tokens[0] !== '=') throw new Error('Expected = but found ' + tokens[0])\n  tokens.shift()\n\n  var version = tokens.shift()\n  switch (version) {\n    case '\"proto2\"':\n      version = 2\n      break\n\n    case '\"proto3\"':\n      version = 3\n      break\n\n    default:\n      throw new Error('Expected protobuf syntax version but found ' + version)\n  }\n\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])\n  tokens.shift()\n\n  return version\n}\n\nvar onenumvalue = function (tokens) {\n  if (tokens.length < 4) throw new Error('Invalid enum value: ' + tokens.slice(0, 3).join(' '))\n  if (tokens[1] !== '=') throw new Error('Expected = but found ' + tokens[1])\n  if (tokens[3] !== ';' && tokens[3] !== '[') throw new Error('Expected ; or [ but found ' + tokens[1])\n\n  var name = tokens.shift()\n  tokens.shift()\n  var val = {\n    value: null,\n    options: {}\n  }\n  val.value = Number(tokens.shift())\n  if (tokens[0] === '[') {\n    val.options = onfieldoptions(tokens)\n  }\n  tokens.shift() // expecting the semicolon here\n\n  return {\n    name: name,\n    val: val\n  }\n}\n\nvar onenum = function (tokens) {\n  tokens.shift()\n  var options = {}\n  var e = {\n    name: tokens.shift(),\n    values: {},\n    options: {}\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      // there goes optional semicolon after the enclosing \"}\"\n      if (tokens[0] === ';') tokens.shift()\n      return e\n    }\n    if (tokens[0] === 'option') {\n      options = onoption(tokens)\n      e.options[options.name] = options.value\n      continue\n    }\n    var val = onenumvalue(tokens)\n    e.values[val.name] = val.val\n  }\n\n  throw new Error('No closing tag for enum')\n}\n\nvar onoption = function (tokens) {\n  var name = null\n  var value = null\n\n  var parse = function (value) {\n    if (value === 'true') return true\n    if (value === 'false') return false\n    return value.replace(/^\"+|\"+$/gm, '')\n  }\n\n  while (tokens.length) {\n    if (tokens[0] === ';') {\n      tokens.shift()\n      return { name: name, value: value }\n    }\n    switch (tokens[0]) {\n      case 'option':\n        tokens.shift()\n\n        var hasBracket = tokens[0] === '('\n        if (hasBracket) tokens.shift()\n\n        name = tokens.shift()\n\n        if (hasBracket) {\n          if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n          tokens.shift()\n        }\n\n        if (tokens[0][0] === '.') {\n          name += tokens.shift()\n        }\n\n        break\n\n      case '=':\n        tokens.shift()\n        if (name === null) throw new Error('Expected key for option with value: ' + tokens[0])\n        value = parse(tokens.shift())\n\n        if (name === 'optimize_for' && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {\n          throw new Error('Unexpected value for option optimize_for: ' + value)\n        } else if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens)\n        }\n        break\n\n      default:\n        throw new Error('Unexpected token in option: ' + tokens[0])\n    }\n  }\n}\n\nvar onoptionMap = function (tokens) {\n  var parse = function (value) {\n    if (value === 'true') return true\n    if (value === 'false') return false\n    return value.replace(/^\"+|\"+$/gm, '')\n  }\n\n  var map = {}\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      return map\n    }\n\n    var hasBracket = tokens[0] === '('\n    if (hasBracket) tokens.shift()\n\n    var key = tokens.shift()\n    if (hasBracket) {\n      if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n      tokens.shift()\n    }\n\n    var value = null\n\n    switch (tokens[0]) {\n      case ':':\n        if (map[key] !== undefined) throw new Error('Duplicate option map key ' + key)\n\n        tokens.shift()\n\n        value = parse(tokens.shift())\n\n        if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens)\n        }\n\n        map[key] = value\n\n        if (tokens[0] === ';') {\n          tokens.shift()\n        }\n        break\n\n      case '{':\n        tokens.shift()\n        value = onoptionMap(tokens)\n\n        if (map[key] === undefined) map[key] = []\n        if (!Array.isArray(map[key])) throw new Error('Duplicate option map key ' + key)\n\n        map[key].push(value)\n        break\n\n      default:\n        throw new Error('Unexpected token in option map: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for option map')\n}\n\nvar onimport = function (tokens) {\n  tokens.shift()\n  var file = tokens.shift().replace(/^\"+|\"+$/gm, '')\n\n  if (tokens[0] !== ';') throw new Error('Unexpected token: ' + tokens[0] + '. Expected \";\"')\n\n  tokens.shift()\n  return file\n}\n\nvar onservice = function (tokens) {\n  tokens.shift()\n\n  var service = {\n    name: tokens.shift(),\n    methods: [],\n    options: {}\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      // there goes optional semicolon after the enclosing \"}\"\n      if (tokens[0] === ';') tokens.shift()\n      return service\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        var opt = onoption(tokens)\n        if (service.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)\n        service.options[opt.name] = opt.value\n        break\n      case 'rpc':\n        service.methods.push(onrpc(tokens))\n        break\n      default:\n        throw new Error('Unexpected token in service: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for service')\n}\n\nvar onrpc = function (tokens) {\n  tokens.shift()\n\n  var rpc = {\n    name: tokens.shift(),\n    input_type: null,\n    output_type: null,\n    client_streaming: false,\n    server_streaming: false,\n    options: {}\n  }\n\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] === 'stream') {\n    tokens.shift()\n    rpc.client_streaming = true\n  }\n\n  rpc.input_type = tokens.shift()\n\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] !== 'returns') throw new Error('Expected returns but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] === 'stream') {\n    tokens.shift()\n    rpc.server_streaming = true\n  }\n\n  rpc.output_type = tokens.shift()\n\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] === ';') {\n    tokens.shift()\n    return rpc\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      // there goes optional semicolon after the enclosing \"}\"\n      if (tokens[0] === ';') tokens.shift()\n      return rpc\n    }\n\n    if (tokens[0] === 'option') {\n      var opt = onoption(tokens)\n      if (rpc.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)\n      rpc.options[opt.name] = opt.value\n    } else {\n      throw new Error('Unexpected token in rpc options: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for rpc')\n}\n\nvar parse = function (buf) {\n  var tokens = tokenize(buf.toString())\n  // check for isolated strings in tokens by looking for opening quote\n  for (var i = 0; i < tokens.length; i++) {\n    if (/^(\"|')([^'\"]*)$/.test(tokens[i])) {\n      var j\n      if (tokens[i].length === 1) {\n        j = i + 1\n      } else {\n        j = i\n      }\n      // look ahead for the closing quote and collapse all\n      // in-between tokens into a single token\n      for (j; j < tokens.length; j++) {\n        if (/^[^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*(\"|')$/.test(tokens[j])) {\n          tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join('')).concat(tokens.slice(j + 1))\n          break\n        }\n      }\n    }\n  }\n  var schema = {\n    syntax: 3,\n    package: null,\n    imports: [],\n    enums: [],\n    messages: [],\n    options: {},\n    extends: []\n  }\n\n  var firstline = true\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'package':\n        schema.package = onpackagename(tokens)\n        break\n\n      case 'syntax':\n        if (!firstline) throw new Error('Protobuf syntax version should be first thing in file')\n        schema.syntax = onsyntaxversion(tokens)\n        break\n\n      case 'message':\n        schema.messages.push(onmessage(tokens))\n        break\n\n      case 'enum':\n        schema.enums.push(onenum(tokens))\n        break\n\n      case 'option':\n        var opt = onoption(tokens)\n        if (schema.options[opt.name]) throw new Error('Duplicate option ' + opt.name)\n        schema.options[opt.name] = opt.value\n        break\n\n      case 'import':\n        schema.imports.push(onimport(tokens))\n        break\n\n      case 'extend':\n        schema.extends.push(onextend(tokens))\n        break\n\n      case 'service':\n        if (!schema.services) schema.services = []\n        schema.services.push(onservice(tokens))\n        break\n\n      default:\n        throw new Error('Unexpected token: ' + tokens[0])\n    }\n    firstline = false\n  }\n\n  // now iterate over messages and propagate extends\n  schema.extends.forEach(function (ext) {\n    schema.messages.forEach(function (msg) {\n      if (msg.name === ext.name) {\n        ext.message.fields.forEach(function (field) {\n          if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {\n            throw new Error(msg.name + ' does not declare ' + field.tag + ' as an extension number')\n          }\n          msg.fields.push(field)\n        })\n      }\n    })\n  })\n\n  schema.messages.forEach(function (msg) {\n    msg.fields.forEach(function (field) {\n      var fieldSplit\n      var messageName\n      var nestedEnumName\n      var message\n\n      function enumNameIsFieldType (en) {\n        return en.name === field.type\n      }\n\n      function enumNameIsNestedEnumName (en) {\n        return en.name === nestedEnumName\n      }\n\n      if (field.options && field.options.packed === 'true') {\n        if (PACKABLE_TYPES.indexOf(field.type) === -1) {\n          // let's see if it's an enum\n          if (field.type.indexOf('.') === -1) {\n            if (msg.enums && msg.enums.some(enumNameIsFieldType)) {\n              return\n            }\n          } else {\n            fieldSplit = field.type.split('.')\n            if (fieldSplit.length > 2) {\n              throw new Error('what is this?')\n            }\n\n            messageName = fieldSplit[0]\n            nestedEnumName = fieldSplit[1]\n\n            schema.messages.some(function (msg) {\n              if (msg.name === messageName) {\n                message = msg\n                return msg\n              }\n            })\n\n            if (message && message.enums && message.enums.some(enumNameIsNestedEnumName)) {\n              return\n            }\n          }\n\n          throw new Error(\n            'Fields of type ' + field.type + ' cannot be declared [packed=true]. ' +\n            'Only repeated fields of primitive numeric types (types which use ' +\n            'the varint, 32-bit, or 64-bit wire types) can be declared \"packed\". ' +\n            'See https://developers.google.com/protocol-buffers/docs/encoding#optional'\n          )\n        }\n      }\n    })\n  })\n\n  return schema\n}\n\nmodule.exports = parse\n"]},"metadata":{},"sourceType":"script"}