{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { setAsPrimitive, map, isTypedArray, assert, each, retrieve2 } from 'zrender/lib/core/util';\nimport { createSource, cloneSourceShallow } from '../Source';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../../util/types';\nimport { querySeriesUpstreamDatasetModel, queryDatasetUpstreamDatasetModels } from './sourceHelper';\nimport { applyDataTransform } from './transform';\n/**\n * [REQUIREMENT_MEMO]:\n * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.\n * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and\n * `root-dataset`. Them on `series` has higher priority.\n * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might\n * confuse users: whether those props indicate how to visit the upstream source or visit\n * the transform result source, and some transforms has nothing to do with these props,\n * and some transforms might have multiple upstream.\n * (3) Transforms should specify `metaRawOption` in each output, just like they can be\n * declared in `root-dataset`.\n * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.\n * That is for reducing complexity in transfroms.\n * PENDING: Whether to provide transposition transform?\n *\n * [IMPLEMENTAION_MEMO]:\n * \"sourceVisitConfig\" are calculated from `metaRawOption` and `data`.\n * They will not be calculated until `source` is about to be visited (to prevent from\n * duplicate calcuation). `source` is visited only in series and input to transforms.\n *\n * [DIMENSION_INHERIT_RULE]:\n * By default the dimensions are inherited from ancestors, unless a transform return\n * a new dimensions definition.\n * Consider the case:\n * ```js\n * dataset: [{\n *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * dataset: [{\n *     dimension: ['Product', 'Sales', 'Prise'],\n *     source: [ ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * ```\n * The two types of option should have the same behavior after transform.\n *\n *\n * [SCENARIO]:\n * (1) Provide source data directly:\n * ```js\n * series: {\n *     encode: {...},\n *     dimensions: [...]\n *     seriesLayoutBy: 'row',\n *     data: [[...]]\n * }\n * ```\n * (2) Series refer to dataset.\n * ```js\n * series: [{\n *     encode: {...}\n *     // Ignore datasetIndex means `datasetIndex: 0`\n *     // and the dimensions defination in dataset is used\n * }, {\n *     encode: {...},\n *     seriesLayoutBy: 'column',\n *     datasetIndex: 1\n * }]\n * ```\n * (3) dataset transform\n * ```js\n * dataset: [{\n *     source: [...]\n * }, {\n *     source: [...]\n * }, {\n *     // By default from 0.\n *     transform: { type: 'filter', config: {...} }\n * }, {\n *     // Piped.\n *     transform: [\n *         { type: 'filter', config: {...} },\n *         { type: 'sort', config: {...} }\n *     ]\n * }, {\n *     id: 'regressionData',\n *     fromDatasetIndex: 1,\n *     // Third-party transform\n *     transform: { type: 'ecStat:regression', config: {...} }\n * }, {\n *     // retrieve the extra result.\n *     id: 'regressionFormula',\n *     fromDatasetId: 'regressionData',\n *     fromTransformResult: 1\n * }]\n * ```\n */\n\nvar SourceManager =\n/** @class */\nfunction () {\n  function SourceManager(sourceHost) {\n    // Cached source. Do not repeat calculating if not dirty.\n    this._sourceList = []; // version sign of each upstream source manager.\n\n    this._upstreamSignList = [];\n    this._versionSignBase = 0;\n    this._sourceHost = sourceHost;\n  }\n  /**\n   * Mark dirty.\n   */\n\n\n  SourceManager.prototype.dirty = function () {\n    this._setLocalSource([], []);\n  };\n\n  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n    this._sourceList = sourceList;\n    this._upstreamSignList = upstreamSignList;\n    this._versionSignBase++;\n\n    if (this._versionSignBase > 9e10) {\n      this._versionSignBase = 0;\n    }\n  };\n  /**\n   * For detecting whether the upstream source is dirty, so that\n   * the local cached source (in `_sourceList`) should be discarded.\n   */\n\n\n  SourceManager.prototype._getVersionSign = function () {\n    return this._sourceHost.uid + '_' + this._versionSignBase;\n  };\n  /**\n   * Always return a source instance. Otherwise throw error.\n   */\n\n\n  SourceManager.prototype.prepareSource = function () {\n    // For the case that call `setOption` multiple time but no data changed,\n    // cache the result source to prevent from repeating transform.\n    if (this._isDirty()) {\n      this._createSource();\n    }\n  };\n\n  SourceManager.prototype._createSource = function () {\n    this._setLocalSource([], []);\n\n    var sourceHost = this._sourceHost;\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    var hasUpstream = !!upSourceMgrList.length;\n    var resultSourceList;\n    var upstreamSignList;\n\n    if (isSeries(sourceHost)) {\n      var seriesModel = sourceHost;\n      var data = void 0;\n      var sourceFormat = void 0;\n      var upSource = void 0; // Has upstream dataset\n\n      if (hasUpstream) {\n        var upSourceMgr = upSourceMgrList[0];\n        upSourceMgr.prepareSource();\n        upSource = upSourceMgr.getSource();\n        data = upSource.data;\n        sourceFormat = upSource.sourceFormat;\n        upstreamSignList = [upSourceMgr._getVersionSign()];\n      } // Series data is from own.\n      else {\n          data = seriesModel.get('data', true);\n          sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n          upstreamSignList = [];\n        } // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.\n\n\n      var newMetaRawOption = this._getSourceMetaRawOption();\n\n      var upMetaRawOption = upSource ? upSource.metaRawOption : null;\n      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption ? upMetaRawOption.seriesLayoutBy : null);\n      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption ? upMetaRawOption.sourceHeader : null); // Note here we should not use `upSource.dimensionsDefine`. Consider the case:\n      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,\n      // but series need `seriesLayoutBy: 'row'`.\n\n      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption ? upMetaRawOption.dimensions : null);\n      resultSourceList = [createSource(data, {\n        seriesLayoutBy: seriesLayoutBy,\n        sourceHeader: sourceHeader,\n        dimensions: dimensions\n      }, sourceFormat, seriesModel.get('encode', true))];\n    } else {\n      var datasetModel = sourceHost; // Has upstream dataset.\n\n      if (hasUpstream) {\n        var result = this._applyTransform(upSourceMgrList);\n\n        resultSourceList = result.sourceList;\n        upstreamSignList = result.upstreamSignList;\n      } // Is root dataset.\n      else {\n          var sourceData = datasetModel.get('source', true);\n          resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null, // Note: dataset option does not have `encode`.\n          null)];\n          upstreamSignList = [];\n        }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(resultSourceList && upstreamSignList);\n    }\n\n    this._setLocalSource(resultSourceList, upstreamSignList);\n  };\n\n  SourceManager.prototype._applyTransform = function (upMgrList) {\n    var datasetModel = this._sourceHost;\n    var transformOption = datasetModel.get('transform', true);\n    var fromTransformResult = datasetModel.get('fromTransformResult', true);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(fromTransformResult != null || transformOption != null);\n    }\n\n    if (fromTransformResult != null) {\n      var errMsg = '';\n\n      if (upMgrList.length !== 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';\n        }\n\n        doThrow(errMsg);\n      }\n    }\n\n    var sourceList;\n    var upSourceList = [];\n    var upstreamSignList = [];\n    each(upMgrList, function (upMgr) {\n      upMgr.prepareSource();\n      var upSource = upMgr.getSource(fromTransformResult || 0);\n      var errMsg = '';\n\n      if (fromTransformResult != null && !upSource) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;\n        }\n\n        doThrow(errMsg);\n      }\n\n      upSourceList.push(upSource);\n      upstreamSignList.push(upMgr._getVersionSign());\n    });\n\n    if (transformOption) {\n      sourceList = applyDataTransform(transformOption, upSourceList, {\n        datasetIndex: datasetModel.componentIndex\n      });\n    } else if (fromTransformResult != null) {\n      sourceList = [cloneSourceShallow(upSourceList[0])];\n    }\n\n    return {\n      sourceList: sourceList,\n      upstreamSignList: upstreamSignList\n    };\n  };\n\n  SourceManager.prototype._isDirty = function () {\n    var sourceList = this._sourceList;\n\n    if (!sourceList.length) {\n      return true;\n    } // All sourceList is from the some upsteam.\n\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    for (var i = 0; i < upSourceMgrList.length; i++) {\n      var upSrcMgr = upSourceMgrList[i];\n\n      if ( // Consider the case that there is ancestor diry, call it recursively.\n      // The performance is probably not an issue because usually the chain is not long.\n      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n        return true;\n      }\n    }\n  };\n  /**\n   * @param sourceIndex By defualt 0, means \"main source\".\n   *                    Most cases there is only one source.\n   */\n\n\n  SourceManager.prototype.getSource = function (sourceIndex) {\n    return this._sourceList[sourceIndex || 0];\n  };\n  /**\n   * PEDING: Is it fast enough?\n   * If no upstream, return empty array.\n   */\n\n\n  SourceManager.prototype._getUpstreamSourceManagers = function () {\n    // Always get the relationship from the raw option.\n    // Do not cache the link of the dependency graph, so that\n    // no need to update them when change happen.\n    var sourceHost = this._sourceHost;\n\n    if (isSeries(sourceHost)) {\n      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);\n      return !datasetModel ? [] : [datasetModel.getSourceManager()];\n    } else {\n      return map(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {\n        return datasetModel.getSourceManager();\n      });\n    }\n  };\n\n  SourceManager.prototype._getSourceMetaRawOption = function () {\n    var sourceHost = this._sourceHost;\n    var seriesLayoutBy;\n    var sourceHeader;\n    var dimensions;\n\n    if (isSeries(sourceHost)) {\n      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n      sourceHeader = sourceHost.get('sourceHeader', true);\n      dimensions = sourceHost.get('dimensions', true);\n    } // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.\n    else if (!this._getUpstreamSourceManagers().length) {\n        var model = sourceHost;\n        seriesLayoutBy = model.get('seriesLayoutBy', true);\n        sourceHeader = model.get('sourceHeader', true);\n        dimensions = model.get('dimensions', true);\n      }\n\n    return {\n      seriesLayoutBy: seriesLayoutBy,\n      sourceHeader: sourceHeader,\n      dimensions: dimensions\n    };\n  };\n\n  return SourceManager;\n}();\n\nexport { SourceManager }; // Call this method after `super.init` and `super.mergeOption` to\n// disable the transform merge, but do not disable transfrom clone from rawOption.\n\nexport function disableTransformOptionMerge(datasetModel) {\n  var transformOption = datasetModel.option.transform;\n  transformOption && setAsPrimitive(datasetModel.option.transform);\n}\n\nfunction isSeries(sourceHost) {\n  // Avoid circular dependency with Series.ts\n  return sourceHost.mainType === 'series';\n}\n\nfunction doThrow(errMsg) {\n  throw new Error(errMsg);\n}","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/echarts/lib/data/helper/sourceManager.js"],"names":["setAsPrimitive","map","isTypedArray","assert","each","retrieve2","createSource","cloneSourceShallow","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ORIGINAL","querySeriesUpstreamDatasetModel","queryDatasetUpstreamDatasetModels","applyDataTransform","SourceManager","sourceHost","_sourceList","_upstreamSignList","_versionSignBase","_sourceHost","prototype","dirty","_setLocalSource","sourceList","upstreamSignList","_getVersionSign","uid","prepareSource","_isDirty","_createSource","upSourceMgrList","_getUpstreamSourceManagers","hasUpstream","length","resultSourceList","isSeries","seriesModel","data","sourceFormat","upSource","upSourceMgr","getSource","get","newMetaRawOption","_getSourceMetaRawOption","upMetaRawOption","metaRawOption","seriesLayoutBy","sourceHeader","dimensions","datasetModel","result","_applyTransform","sourceData","process","env","NODE_ENV","upMgrList","transformOption","fromTransformResult","errMsg","doThrow","upSourceList","upMgr","push","datasetIndex","componentIndex","i","upSrcMgr","sourceIndex","getSourceManager","model","disableTransformOptionMerge","option","transform","mainType","Error"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAT,EAAyBC,GAAzB,EAA8BC,YAA9B,EAA4CC,MAA5C,EAAoDC,IAApD,EAA0DC,SAA1D,QAA2E,uBAA3E;AACA,SAASC,YAAT,EAAuBC,kBAAvB,QAAiD,WAAjD;AACA,SAASC,yBAAT,EAAoCC,sBAApC,QAAkE,kBAAlE;AACA,SAASC,+BAAT,EAA0CC,iCAA1C,QAAmF,gBAAnF;AACA,SAASC,kBAAT,QAAmC,aAAnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,aAAa;AACjB;AACA,YAAY;AACV,WAASA,aAAT,CAAuBC,UAAvB,EAAmC;AACjC;AACA,SAAKC,WAAL,GAAmB,EAAnB,CAFiC,CAEV;;AAEvB,SAAKC,iBAAL,GAAyB,EAAzB;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKC,WAAL,GAAmBJ,UAAnB;AACD;AACD;AACF;AACA;;;AAGED,EAAAA,aAAa,CAACM,SAAd,CAAwBC,KAAxB,GAAgC,YAAY;AAC1C,SAAKC,eAAL,CAAqB,E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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { setAsPrimitive, map, isTypedArray, assert, each, retrieve2 } from 'zrender/lib/core/util';\nimport { createSource, cloneSourceShallow } from '../Source';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../../util/types';\nimport { querySeriesUpstreamDatasetModel, queryDatasetUpstreamDatasetModels } from './sourceHelper';\nimport { applyDataTransform } from './transform';\n/**\n * [REQUIREMENT_MEMO]:\n * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.\n * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and\n * `root-dataset`. Them on `series` has higher priority.\n * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might\n * confuse users: whether those props indicate how to visit the upstream source or visit\n * the transform result source, and some transforms has nothing to do with these props,\n * and some transforms might have multiple upstream.\n * (3) Transforms should specify `metaRawOption` in each output, just like they can be\n * declared in `root-dataset`.\n * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.\n * That is for reducing complexity in transfroms.\n * PENDING: Whether to provide transposition transform?\n *\n * [IMPLEMENTAION_MEMO]:\n * \"sourceVisitConfig\" are calculated from `metaRawOption` and `data`.\n * They will not be calculated until `source` is about to be visited (to prevent from\n * duplicate calcuation). `source` is visited only in series and input to transforms.\n *\n * [DIMENSION_INHERIT_RULE]:\n * By default the dimensions are inherited from ancestors, unless a transform return\n * a new dimensions definition.\n * Consider the case:\n * ```js\n * dataset: [{\n *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * dataset: [{\n *     dimension: ['Product', 'Sales', 'Prise'],\n *     source: [ ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * ```\n * The two types of option should have the same behavior after transform.\n *\n *\n * [SCENARIO]:\n * (1) Provide source data directly:\n * ```js\n * series: {\n *     encode: {...},\n *     dimensions: [...]\n *     seriesLayoutBy: 'row',\n *     data: [[...]]\n * }\n * ```\n * (2) Series refer to dataset.\n * ```js\n * series: [{\n *     encode: {...}\n *     // Ignore datasetIndex means `datasetIndex: 0`\n *     // and the dimensions defination in dataset is used\n * }, {\n *     encode: {...},\n *     seriesLayoutBy: 'column',\n *     datasetIndex: 1\n * }]\n * ```\n * (3) dataset transform\n * ```js\n * dataset: [{\n *     source: [...]\n * }, {\n *     source: [...]\n * }, {\n *     // By default from 0.\n *     transform: { type: 'filter', config: {...} }\n * }, {\n *     // Piped.\n *     transform: [\n *         { type: 'filter', config: {...} },\n *         { type: 'sort', config: {...} }\n *     ]\n * }, {\n *     id: 'regressionData',\n *     fromDatasetIndex: 1,\n *     // Third-party transform\n *     transform: { type: 'ecStat:regression', config: {...} }\n * }, {\n *     // retrieve the extra result.\n *     id: 'regressionFormula',\n *     fromDatasetId: 'regressionData',\n *     fromTransformResult: 1\n * }]\n * ```\n */\n\nvar SourceManager =\n/** @class */\nfunction () {\n  function SourceManager(sourceHost) {\n    // Cached source. Do not repeat calculating if not dirty.\n    this._sourceList = []; // version sign of each upstream source manager.\n\n    this._upstreamSignList = [];\n    this._versionSignBase = 0;\n    this._sourceHost = sourceHost;\n  }\n  /**\n   * Mark dirty.\n   */\n\n\n  SourceManager.prototype.dirty = function () {\n    this._setLocalSource([], []);\n  };\n\n  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n    this._sourceList = sourceList;\n    this._upstreamSignList = upstreamSignList;\n    this._versionSignBase++;\n\n    if (this._versionSignBase > 9e10) {\n      this._versionSignBase = 0;\n    }\n  };\n  /**\n   * For detecting whether the upstream source is dirty, so that\n   * the local cached source (in `_sourceList`) should be discarded.\n   */\n\n\n  SourceManager.prototype._getVersionSign = function () {\n    return this._sourceHost.uid + '_' + this._versionSignBase;\n  };\n  /**\n   * Always return a source instance. Otherwise throw error.\n   */\n\n\n  SourceManager.prototype.prepareSource = function () {\n    // For the case that call `setOption` multiple time but no data changed,\n    // cache the result source to prevent from repeating transform.\n    if (this._isDirty()) {\n      this._createSource();\n    }\n  };\n\n  SourceManager.prototype._createSource = function () {\n    this._setLocalSource([], []);\n\n    var sourceHost = this._sourceHost;\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    var hasUpstream = !!upSourceMgrList.length;\n    var resultSourceList;\n    var upstreamSignList;\n\n    if (isSeries(sourceHost)) {\n      var seriesModel = sourceHost;\n      var data = void 0;\n      var sourceFormat = void 0;\n      var upSource = void 0; // Has upstream dataset\n\n      if (hasUpstream) {\n        var upSourceMgr = upSourceMgrList[0];\n        upSourceMgr.prepareSource();\n        upSource = upSourceMgr.getSource();\n        data = upSource.data;\n        sourceFormat = upSource.sourceFormat;\n        upstreamSignList = [upSourceMgr._getVersionSign()];\n      } // Series data is from own.\n      else {\n          data = seriesModel.get('data', true);\n          sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n          upstreamSignList = [];\n        } // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.\n\n\n      var newMetaRawOption = this._getSourceMetaRawOption();\n\n      var upMetaRawOption = upSource ? upSource.metaRawOption : null;\n      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption ? upMetaRawOption.seriesLayoutBy : null);\n      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption ? upMetaRawOption.sourceHeader : null); // Note here we should not use `upSource.dimensionsDefine`. Consider the case:\n      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,\n      // but series need `seriesLayoutBy: 'row'`.\n\n      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption ? upMetaRawOption.dimensions : null);\n      resultSourceList = [createSource(data, {\n        seriesLayoutBy: seriesLayoutBy,\n        sourceHeader: sourceHeader,\n        dimensions: dimensions\n      }, sourceFormat, seriesModel.get('encode', true))];\n    } else {\n      var datasetModel = sourceHost; // Has upstream dataset.\n\n      if (hasUpstream) {\n        var result = this._applyTransform(upSourceMgrList);\n\n        resultSourceList = result.sourceList;\n        upstreamSignList = result.upstreamSignList;\n      } // Is root dataset.\n      else {\n          var sourceData = datasetModel.get('source', true);\n          resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null, // Note: dataset option does not have `encode`.\n          null)];\n          upstreamSignList = [];\n        }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(resultSourceList && upstreamSignList);\n    }\n\n    this._setLocalSource(resultSourceList, upstreamSignList);\n  };\n\n  SourceManager.prototype._applyTransform = function (upMgrList) {\n    var datasetModel = this._sourceHost;\n    var transformOption = datasetModel.get('transform', true);\n    var fromTransformResult = datasetModel.get('fromTransformResult', true);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(fromTransformResult != null || transformOption != null);\n    }\n\n    if (fromTransformResult != null) {\n      var errMsg = '';\n\n      if (upMgrList.length !== 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';\n        }\n\n        doThrow(errMsg);\n      }\n    }\n\n    var sourceList;\n    var upSourceList = [];\n    var upstreamSignList = [];\n    each(upMgrList, function (upMgr) {\n      upMgr.prepareSource();\n      var upSource = upMgr.getSource(fromTransformResult || 0);\n      var errMsg = '';\n\n      if (fromTransformResult != null && !upSource) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;\n        }\n\n        doThrow(errMsg);\n      }\n\n      upSourceList.push(upSource);\n      upstreamSignList.push(upMgr._getVersionSign());\n    });\n\n    if (transformOption) {\n      sourceList = applyDataTransform(transformOption, upSourceList, {\n        datasetIndex: datasetModel.componentIndex\n      });\n    } else if (fromTransformResult != null) {\n      sourceList = [cloneSourceShallow(upSourceList[0])];\n    }\n\n    return {\n      sourceList: sourceList,\n      upstreamSignList: upstreamSignList\n    };\n  };\n\n  SourceManager.prototype._isDirty = function () {\n    var sourceList = this._sourceList;\n\n    if (!sourceList.length) {\n      return true;\n    } // All sourceList is from the some upsteam.\n\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    for (var i = 0; i < upSourceMgrList.length; i++) {\n      var upSrcMgr = upSourceMgrList[i];\n\n      if ( // Consider the case that there is ancestor diry, call it recursively.\n      // The performance is probably not an issue because usually the chain is not long.\n      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n        return true;\n      }\n    }\n  };\n  /**\n   * @param sourceIndex By defualt 0, means \"main source\".\n   *                    Most cases there is only one source.\n   */\n\n\n  SourceManager.prototype.getSource = function (sourceIndex) {\n    return this._sourceList[sourceIndex || 0];\n  };\n  /**\n   * PEDING: Is it fast enough?\n   * If no upstream, return empty array.\n   */\n\n\n  SourceManager.prototype._getUpstreamSourceManagers = function () {\n    // Always get the relationship from the raw option.\n    // Do not cache the link of the dependency graph, so that\n    // no need to update them when change happen.\n    var sourceHost = this._sourceHost;\n\n    if (isSeries(sourceHost)) {\n      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);\n      return !datasetModel ? [] : [datasetModel.getSourceManager()];\n    } else {\n      return map(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {\n        return datasetModel.getSourceManager();\n      });\n    }\n  };\n\n  SourceManager.prototype._getSourceMetaRawOption = function () {\n    var sourceHost = this._sourceHost;\n    var seriesLayoutBy;\n    var sourceHeader;\n    var dimensions;\n\n    if (isSeries(sourceHost)) {\n      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n      sourceHeader = sourceHost.get('sourceHeader', true);\n      dimensions = sourceHost.get('dimensions', true);\n    } // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.\n    else if (!this._getUpstreamSourceManagers().length) {\n        var model = sourceHost;\n        seriesLayoutBy = model.get('seriesLayoutBy', true);\n        sourceHeader = model.get('sourceHeader', true);\n        dimensions = model.get('dimensions', true);\n      }\n\n    return {\n      seriesLayoutBy: seriesLayoutBy,\n      sourceHeader: sourceHeader,\n      dimensions: dimensions\n    };\n  };\n\n  return SourceManager;\n}();\n\nexport { SourceManager }; // Call this method after `super.init` and `super.mergeOption` to\n// disable the transform merge, but do not disable transfrom clone from rawOption.\n\nexport function disableTransformOptionMerge(datasetModel) {\n  var transformOption = datasetModel.option.transform;\n  transformOption && setAsPrimitive(datasetModel.option.transform);\n}\n\nfunction isSeries(sourceHost) {\n  // Avoid circular dependency with Series.ts\n  return sourceHost.mainType === 'series';\n}\n\nfunction doThrow(errMsg) {\n  throw new Error(errMsg);\n}"]},"metadata":{},"sourceType":"module"}