{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @deprecated\n * Use `echarts/data/helper/createDimensions` instead.\n */\nimport { createHashMap, each, isString, defaults, extend, isObject, clone } from 'zrender/lib/core/util';\nimport { normalizeToArray } from '../../util/model';\nimport { guessOrdinal, BE_ORDINAL } from './sourceHelper';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source';\nimport { VISUAL_DIMENSIONS } from '../../util/types';\nimport DataDimensionInfo from '../DataDimensionInfo';\n/**\n * @see {module:echarts/test/ut/spec/data/completeDimensions}\n *\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `sysDims`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimsDef` and `opt.encodeDef`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      properties: 'name', 'type', 'displayName'.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: [string|Object, ...]}, ...] dimsDef of sysDim item provides default dim name, and\n *                                    provide dims count that the sysDim required.\n *      [{ordinalMeta}] can be specified.\n * @param {module:echarts/data/Source|Array|Object} source or data (for compatibal with pervious)\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object|HashMap} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {Function} [opt.encodeDefaulter] Called if no `opt.encodeDef` exists.\n *      If not specified, auto find the next available data dim.\n *      param source {module:data/Source}\n *      param dimCount {number}\n *      return {Object} encode Never be `null/undefined`.\n * @param {string} [opt.generateCoord] Generate coord dim with the given name.\n *      If not specified, extra dim names will be:\n *      'value', 'value0', 'value1', ...\n * @param {number} [opt.generateCoordCount] By default, the generated dim name is `generateCoord`.\n *      If `generateCoordCount` specified, the generated dim names will be:\n *      `generateCoord` + 0, `generateCoord` + 1, ...\n *      can be Infinity, indicate that use all of the remain columns.\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<module:data/DataDimensionInfo>}\n */\n\nfunction completeDimensions(sysDims, source, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  sysDims = (sysDims || []).slice();\n  var dimsDef = (opt.dimsDef || []).slice();\n  var dataDimNameMap = createHashMap();\n  var coordDimNameMap = createHashMap(); // let valueCandidate;\n\n  var result = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount); // Apply user defined dims (`name` and `type`) and init result.\n\n  for (var i = 0; i < dimCount; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var dimDefItem = dimsDef[i] = extend({}, isObject(dimDefItemRaw) ? dimDefItemRaw : {\n      name: dimDefItemRaw\n    });\n    var userDimName = dimDefItem.name;\n    var resultItem = result[i] = new DataDimensionInfo(); // Name will be applied later for avoiding duplication.\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      // Only if `series.dimensions` is defined in option\n      // displayName, will be set, and dimension will be diplayed vertically in\n      // tooltip by default.\n      resultItem.name = resultItem.displayName = userDimName;\n      dataDimNameMap.set(userDimName, i);\n    }\n\n    dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n    dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n  }\n\n  var encodeDef = opt.encodeDef;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef); // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(result[resultDimIdx], coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = clone(sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < result.length && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = result[resultDimIdx];\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value'; // Set dim `name` and other `coordDim` and other props.\n\n  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n    var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo();\n    var coordDim = resultItem.coordDim;\n\n    if (coordDim == null) {\n      resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);\n      resultItem.coordDimIndex = 0;\n\n      if (!generateCoord || generateCoordCount <= 0) {\n        resultItem.isExtraCoord = true;\n      }\n\n      generateCoordCount--;\n    }\n\n    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap, false));\n\n    if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n    // {\n    //    dataset: {source: [\n    //        ['2001', 123],\n    //        ['2002', 456],\n    //        ...\n    //        ['The others', 987],\n    //    ]},\n    //    series: {type: 'pie'}\n    // }\n    // The first colum should better be treated as a \"ordinal\" although it\n    // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n    || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n      resultItem.type = 'ordinal';\n    }\n  }\n\n  return result;\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in storage?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genName(name, map, fromZero) {\n  if (fromZero || map.get(name) != null) {\n    var i = 0;\n\n    while (map.get(name + i) != null) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}\n\nexport default completeDimensions;","map":{"version":3,"sources":["/home/kzj/project/finalize/B-S-/源码/前端/node_modules/echarts/lib/data/helper/completeDimensions.js"],"names":["createHashMap","each","isString","defaults","extend","isObject","clone","normalizeToArray","guessOrdinal","BE_ORDINAL","createSourceFromSeriesDataOption","isSourceInstance","VISUAL_DIMENSIONS","DataDimensionInfo","completeDimensions","sysDims","source","opt","slice","dimsDef","dataDimNameMap","coordDimNameMap","result","dimCount","getDimCount","i","dimDefItemRaw","dimDefItem","name","userDimName","resultItem","get","displayName","set","type","encodeDef","encodeDefaulter","encodeDefMap","dataDimsRaw","coordDim","dataDims","length","validDataDims","resultDimIdxOrName","idx","resultDimIdx","applyDim","availDimIdx","sysDimItemRaw","sysDimItemDimsDef","sysDimItemOtherDims","sysDimItem","ordinalMeta","otherDims","coordDimIndex","push","sysDimItemDimsDefItem","defaultTooltip","generateCoord","generateCoordCount","fromZero","extra","genName","isExtraCoord","Must","itemName","seriesName","optDimCount","Math","max","dimensionsDetectedCount","map"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @deprecated\n * Use `echarts/data/helper/createDimensions` instead.\n */\nimport { createHashMap, each, isString, defaults, extend, isObject, clone } from 'zrender/lib/core/util';\nimport { normalizeToArray } from '../../util/model';\nimport { guessOrdinal, BE_ORDINAL } from './sourceHelper';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source';\nimport { VISUAL_DIMENSIONS } from '../../util/types';\nimport DataDimensionInfo from '../DataDimensionInfo';\n/**\n * @see {module:echarts/test/ut/spec/data/completeDimensions}\n *\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `sysDims`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimsDef` and `opt.encodeDef`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      properties: 'name', 'type', 'displayName'.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: [string|Object, ...]}, ...] dimsDef of sysDim item provides default dim name, and\n *                                    provide dims count that the sysDim required.\n *      [{ordinalMeta}] can be specified.\n * @param {module:echarts/data/Source|Array|Object} source or data (for compatibal with pervious)\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object|HashMap} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {Function} [opt.encodeDefaulter] Called if no `opt.encodeDef` exists.\n *      If not specified, auto find the next available data dim.\n *      param source {module:data/Source}\n *      param dimCount {number}\n *      return {Object} encode Never be `null/undefined`.\n * @param {string} [opt.generateCoord] Generate coord dim with the given name.\n *      If not specified, extra dim names will be:\n *      'value', 'value0', 'value1', ...\n * @param {number} [opt.generateCoordCount] By default, the generated dim name is `generateCoord`.\n *      If `generateCoordCount` specified, the generated dim names will be:\n *      `generateCoord` + 0, `generateCoord` + 1, ...\n *      can be Infinity, indicate that use all of the remain columns.\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<module:data/DataDimensionInfo>}\n */\n\nfunction completeDimensions(sysDims, source, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  sysDims = (sysDims || []).slice();\n  var dimsDef = (opt.dimsDef || []).slice();\n  var dataDimNameMap = createHashMap();\n  var coordDimNameMap = createHashMap(); // let valueCandidate;\n\n  var result = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount); // Apply user defined dims (`name` and `type`) and init result.\n\n  for (var i = 0; i < dimCount; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var dimDefItem = dimsDef[i] = extend({}, isObject(dimDefItemRaw) ? dimDefItemRaw : {\n      name: dimDefItemRaw\n    });\n    var userDimName = dimDefItem.name;\n    var resultItem = result[i] = new DataDimensionInfo(); // Name will be applied later for avoiding duplication.\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      // Only if `series.dimensions` is defined in option\n      // displayName, will be set, and dimension will be diplayed vertically in\n      // tooltip by default.\n      resultItem.name = resultItem.displayName = userDimName;\n      dataDimNameMap.set(userDimName, i);\n    }\n\n    dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n    dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n  }\n\n  var encodeDef = opt.encodeDef;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef); // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(result[resultDimIdx], coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = clone(sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < result.length && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = result[resultDimIdx];\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value'; // Set dim `name` and other `coordDim` and other props.\n\n  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n    var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo();\n    var coordDim = resultItem.coordDim;\n\n    if (coordDim == null) {\n      resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);\n      resultItem.coordDimIndex = 0;\n\n      if (!generateCoord || generateCoordCount <= 0) {\n        resultItem.isExtraCoord = true;\n      }\n\n      generateCoordCount--;\n    }\n\n    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap, false));\n\n    if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n    // {\n    //    dataset: {source: [\n    //        ['2001', 123],\n    //        ['2002', 456],\n    //        ...\n    //        ['The others', 987],\n    //    ]},\n    //    series: {type: 'pie'}\n    // }\n    // The first colum should better be treated as a \"ordinal\" although it\n    // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n    || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n      resultItem.type = 'ordinal';\n    }\n  }\n\n  return result;\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in storage?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genName(name, map, fromZero) {\n  if (fromZero || map.get(name) != null) {\n    var i = 0;\n\n    while (map.get(name + i) != null) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}\n\nexport default completeDimensions;"]},"metadata":{},"sourceType":"module"}