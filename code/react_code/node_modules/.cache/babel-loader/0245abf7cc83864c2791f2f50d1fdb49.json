{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as graphic from '../../util/graphic';\nimport SymbolClz from './Symbol';\nimport { isObject } from 'zrender/lib/core/util';\nimport { getLabelStatesModels } from '../../label/labelStyle';\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  var emphasisModel = seriesModel.getModel('emphasis');\n  return {\n    emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),\n    blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),\n    selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),\n    focus: emphasisModel.get('focus'),\n    blurScope: emphasisModel.get('blurScope'),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverScale: emphasisModel.get('scale'),\n    labelStatesModels: getLabelStatesModels(seriesModel),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar SymbolDraw =\n/** @class */\nfunction () {\n  function SymbolDraw(SymbolCtor) {\n    this.group = new graphic.Group();\n    this._SymbolCtor = SymbolCtor || SymbolClz;\n  }\n  /**\n   * Update symbols draw by new data\n   */\n\n\n  SymbolDraw.prototype.updateData = function (data, opt) {\n    opt = normalizeUpdateOpt(opt);\n    var group = this.group;\n    var seriesModel = data.hostModel;\n    var oldData = this._data;\n    var SymbolCtor = this._SymbolCtor;\n    var disableAnimation = opt.disableAnimation;\n    var seriesScope = makeSeriesScope(data);\n    var symbolUpdateOpt = {\n      disableAnimation: disableAnimation\n    };\n\n    var getSymbolPoint = opt.getSymbolPoint || function (idx) {\n      return data.getItemLayout(idx);\n    }; // There is no oldLineData only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n\n\n    if (!oldData) {\n      group.removeAll();\n    }\n\n    data.diff(oldData).add(function (newIdx) {\n      var point = getSymbolPoint(newIdx);\n\n      if (symbolNeedsDraw(data, point, newIdx, opt)) {\n        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);\n        symbolEl.setPosition(point);\n        data.setItemGraphicEl(newIdx, symbolEl);\n        group.add(symbolEl);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n      var point = getSymbolPoint(newIdx);\n\n      if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n        group.remove(symbolEl);\n        return;\n      }\n\n      if (!symbolEl) {\n        symbolEl = new SymbolCtor(data, newIdx);\n        symbolEl.setPosition(point);\n      } else {\n        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);\n        var target = {\n          x: point[0],\n          y: point[1]\n        };\n        disableAnimation ? symbolEl.attr(target) : graphic.updateProps(symbolEl, target, seriesModel);\n      } // Add back\n\n\n      group.add(symbolEl);\n      data.setItemGraphicEl(newIdx, symbolEl);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && el.fadeOut(function () {\n        group.remove(el);\n      });\n    }).execute();\n    this._getSymbolPoint = getSymbolPoint;\n    this._data = data;\n  };\n\n  ;\n\n  SymbolDraw.prototype.isPersistent = function () {\n    return true;\n  };\n\n  ;\n\n  SymbolDraw.prototype.updateLayout = function () {\n    var _this = this;\n\n    var data = this._data;\n\n    if (data) {\n      // Not use animation\n      data.eachItemGraphicEl(function (el, idx) {\n        var point = _this._getSymbolPoint(idx);\n\n        el.setPosition(point);\n        el.markRedraw();\n      });\n    }\n  };\n\n  ;\n\n  SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this._seriesScope = makeSeriesScope(data);\n    this._data = null;\n    this.group.removeAll();\n  };\n\n  ;\n  /**\n   * Update symbols draw by new data\n   */\n\n  SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n    opt = normalizeUpdateOpt(opt);\n\n    function updateIncrementalAndHover(el) {\n      if (!el.isGroup) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n\n    for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n      var point = data.getItemLayout(idx);\n\n      if (symbolNeedsDraw(data, point, idx, opt)) {\n        var el = new this._SymbolCtor(data, idx, this._seriesScope);\n        el.traverse(updateIncrementalAndHover);\n        el.setPosition(point);\n        this.group.add(el);\n        data.setItemGraphicEl(idx, el);\n      }\n    }\n  };\n\n  ;\n\n  SymbolDraw.prototype.remove = function (enableAnimation) {\n    var group = this.group;\n    var data = this._data; // Incremental model do not have this._data.\n\n    if (data && enableAnimation) {\n      data.eachItemGraphicEl(function (el) {\n        el.fadeOut(function () {\n          group.remove(el);\n        });\n      });\n    } else {\n      group.removeAll();\n    }\n  };\n\n  ;\n  return SymbolDraw;\n}();\n\nexport default SymbolDraw;","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/echarts/lib/chart/helper/SymbolDraw.js"],"names":["graphic","SymbolClz","isObject","getLabelStatesModels","symbolNeedsDraw","data","point","idx","opt","isNaN","isIgnore","clipShape","contain","getItemVisual","normalizeUpdateOpt","makeSeriesScope","seriesModel","hostModel","emphasisModel","getModel","emphasisItemStyle","getItemStyle","blurItemStyle","selectItemStyle","focus","get","blurScope","symbolRotate","symbolOffset","hoverScale","labelStatesModels","cursorStyle","SymbolDraw","SymbolCtor","group","Group","_SymbolCtor","prototype","updateData","oldData","_data","disableAnimation","seriesScope","symbolUpdateOpt","getSymbolPoint","getItemLayout","removeAll","diff","add","newIdx","symbolEl","setPosition","setItemGraphicEl","update","oldIdx","getItemGraphicEl","remove","target","x","y","attr","updateProps","el","fadeOut","execute","_getSymbolPoint","isPersistent","updateLayout","_this","eachItemGraphicEl","markRedraw","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","incremental","ensureState","hoverLayer","start","end","traverse","enableAnimation"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as graphic from '../../util/graphic';\nimport SymbolClz from './Symbol';\nimport { isObject } from 'zrender/lib/core/util';\nimport { getLabelStatesModels } from '../../label/labelStyle';\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  var emphasisModel = seriesModel.getModel('emphasis');\n  return {\n    emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),\n    blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),\n    selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),\n    focus: emphasisModel.get('focus'),\n    blurScope: emphasisModel.get('blurScope'),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverScale: emphasisModel.get('scale'),\n    labelStatesModels: getLabelStatesModels(seriesModel),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar SymbolDraw =\n/** @class */\nfunction () {\n  function SymbolDraw(SymbolCtor) {\n    this.group = new graphic.Group();\n    this._SymbolCtor = SymbolCtor || SymbolClz;\n  }\n  /**\n   * Update symbols draw by new data\n   */\n\n\n  SymbolDraw.prototype.updateData = function (data, opt) {\n    opt = normalizeUpdateOpt(opt);\n    var group = this.group;\n    var seriesModel = data.hostModel;\n    var oldData = this._data;\n    var SymbolCtor = this._SymbolCtor;\n    var disableAnimation = opt.disableAnimation;\n    var seriesScope = makeSeriesScope(data);\n    var symbolUpdateOpt = {\n      disableAnimation: disableAnimation\n    };\n\n    var getSymbolPoint = opt.getSymbolPoint || function (idx) {\n      return data.getItemLayout(idx);\n    }; // There is no oldLineData only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n\n\n    if (!oldData) {\n      group.removeAll();\n    }\n\n    data.diff(oldData).add(function (newIdx) {\n      var point = getSymbolPoint(newIdx);\n\n      if (symbolNeedsDraw(data, point, newIdx, opt)) {\n        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);\n        symbolEl.setPosition(point);\n        data.setItemGraphicEl(newIdx, symbolEl);\n        group.add(symbolEl);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n      var point = getSymbolPoint(newIdx);\n\n      if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n        group.remove(symbolEl);\n        return;\n      }\n\n      if (!symbolEl) {\n        symbolEl = new SymbolCtor(data, newIdx);\n        symbolEl.setPosition(point);\n      } else {\n        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);\n        var target = {\n          x: point[0],\n          y: point[1]\n        };\n        disableAnimation ? symbolEl.attr(target) : graphic.updateProps(symbolEl, target, seriesModel);\n      } // Add back\n\n\n      group.add(symbolEl);\n      data.setItemGraphicEl(newIdx, symbolEl);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && el.fadeOut(function () {\n        group.remove(el);\n      });\n    }).execute();\n    this._getSymbolPoint = getSymbolPoint;\n    this._data = data;\n  };\n\n  ;\n\n  SymbolDraw.prototype.isPersistent = function () {\n    return true;\n  };\n\n  ;\n\n  SymbolDraw.prototype.updateLayout = function () {\n    var _this = this;\n\n    var data = this._data;\n\n    if (data) {\n      // Not use animation\n      data.eachItemGraphicEl(function (el, idx) {\n        var point = _this._getSymbolPoint(idx);\n\n        el.setPosition(point);\n        el.markRedraw();\n      });\n    }\n  };\n\n  ;\n\n  SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this._seriesScope = makeSeriesScope(data);\n    this._data = null;\n    this.group.removeAll();\n  };\n\n  ;\n  /**\n   * Update symbols draw by new data\n   */\n\n  SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n    opt = normalizeUpdateOpt(opt);\n\n    function updateIncrementalAndHover(el) {\n      if (!el.isGroup) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n\n    for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n      var point = data.getItemLayout(idx);\n\n      if (symbolNeedsDraw(data, point, idx, opt)) {\n        var el = new this._SymbolCtor(data, idx, this._seriesScope);\n        el.traverse(updateIncrementalAndHover);\n        el.setPosition(point);\n        this.group.add(el);\n        data.setItemGraphicEl(idx, el);\n      }\n    }\n  };\n\n  ;\n\n  SymbolDraw.prototype.remove = function (enableAnimation) {\n    var group = this.group;\n    var data = this._data; // Incremental model do not have this._data.\n\n    if (data && enableAnimation) {\n      data.eachItemGraphicEl(function (el) {\n        el.fadeOut(function () {\n          group.remove(el);\n        });\n      });\n    } else {\n      group.removeAll();\n    }\n  };\n\n  ;\n  return SymbolDraw;\n}();\n\nexport default SymbolDraw;"]},"metadata":{},"sourceType":"module"}