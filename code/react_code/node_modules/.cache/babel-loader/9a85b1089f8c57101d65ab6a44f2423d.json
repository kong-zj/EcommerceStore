{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends, __spreadArrays } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util';\nimport env from 'zrender/lib/core/env';\nimport * as modelUtil from '../util/model';\nimport ComponentModel from './Component';\nimport { PaletteMixin } from './mixin/palette';\nimport { DataFormatMixin } from '../model/mixin/dataFormat';\nimport { getLayoutParams, mergeLayoutParam, fetchLayoutMode } from '../util/layout';\nimport { createTask } from '../core/task';\nimport { mountExtend } from '../util/clazz';\nimport { SourceManager } from '../data/helper/sourceManager';\nimport { defaultSeriesFormatTooltip } from '../component/tooltip/seriesFormatTooltip';\nvar inner = modelUtil.makeInner();\n\nfunction getSelectionKey(data, dataIndex) {\n  return data.getName(dataIndex) || data.getId(dataIndex);\n}\n\nvar SeriesModel =\n/** @class */\nfunction (_super) {\n  __extends(SeriesModel, _super);\n\n  function SeriesModel() {\n    // [Caution]: Becuase this class or desecendants can be used as `XXX.extend(subProto)`,\n    // the class members must not be initialized in constructor or declaration place.\n    // Otherwise there is bad case:\n    //   class A {xxx = 1;}\n    //   enableClassExtend(A);\n    //   class B extends A {}\n    //   var C = B.extend({xxx: 5});\n    //   var c = new C();\n    //   console.log(c.xxx); // expect 5 but always 1.\n    var _this = _super !== null && _super.apply(this, arguments) || this; // ---------------------------------------\n    // Props about data selection\n    // ---------------------------------------\n\n\n    _this._selectedDataIndicesMap = {};\n    return _this;\n  }\n\n  SeriesModel.prototype.init = function (option, parentModel, ecModel) {\n    this.seriesIndex = this.componentIndex;\n    this.dataTask = createTask({\n      count: dataTaskCount,\n      reset: dataTaskReset\n    });\n    this.dataTask.context = {\n      model: this\n    };\n    this.mergeDefaultAndTheme(option, ecModel);\n    var sourceManager = inner(this).sourceManager = new SourceManager(this);\n    sourceManager.prepareSource();\n    var data = this.getInitialData(option, ecModel);\n    wrapData(data, this);\n    this.dataTask.context.data = data;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(data, 'getInitialData returned invalid data.');\n    }\n\n    inner(this).dataBeforeProcessed = data; // If we reverse the order (make data firstly, and then make\n    // dataBeforeProcessed by cloneShallow), cloneShallow will\n    // cause data.graph.data !== data when using\n    // module:echarts/data/Graph or module:echarts/data/Tree.\n    // See module:echarts/data/helper/linkList\n    // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model\n    // init or merge stage, because the data can be restored. So we do not `restoreData`\n    // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.\n    // Call `seriesModel.getRawData()` instead.\n    // this.restoreData();\n\n    autoSeriesName(this);\n\n    this._initSelectedMapFromData(data);\n  };\n  /**\n   * Util for merge default and theme to option\n   */\n\n\n  SeriesModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n    var layoutMode = fetchLayoutMode(this);\n    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.\n    // But if name duplicate between series subType\n    // (for example: parallel) add component mainType,\n    // add suffix 'Series'.\n\n    var themeSubType = this.subType;\n\n    if (ComponentModel.hasClass(themeSubType)) {\n      themeSubType += 'Series';\n    }\n\n    zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`\n\n    modelUtil.defaultEmphasis(option, 'label', ['show']);\n    this.fillDataTextStyle(option.data);\n\n    if (layoutMode) {\n      mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  };\n\n  SeriesModel.prototype.mergeOption = function (newSeriesOption, ecModel) {\n    // this.settingTask.dirty();\n    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n    this.fillDataTextStyle(newSeriesOption.data);\n    var layoutMode = fetchLayoutMode(this);\n\n    if (layoutMode) {\n      mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n    }\n\n    var sourceManager = inner(this).sourceManager;\n    sourceManager.dirty();\n    sourceManager.prepareSource();\n    var data = this.getInitialData(newSeriesOption, ecModel);\n    wrapData(data, this);\n    this.dataTask.dirty();\n    this.dataTask.context.data = data;\n    inner(this).dataBeforeProcessed = data;\n    autoSeriesName(this);\n\n    this._initSelectedMapFromData(data);\n  };\n\n  SeriesModel.prototype.fillDataTextStyle = function (data) {\n    // Default data label emphasis `show`\n    // FIXME Tree structure data ?\n    // FIXME Performance ?\n    if (data && !zrUtil.isTypedArray(data)) {\n      var props = ['show'];\n\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] && data[i].label) {\n          modelUtil.defaultEmphasis(data[i], 'label', props);\n        }\n      }\n    }\n  };\n  /**\n   * Init a data structure from data related option in series\n   * Must be overriden.\n   */\n\n\n  SeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return;\n  };\n  /**\n   * Append data to list\n   */\n\n\n  SeriesModel.prototype.appendData = function (params) {\n    // FIXME ???\n    // (1) If data from dataset, forbidden append.\n    // (2) support append data of dataset.\n    var data = this.getRawData();\n    data.appendData(params.data);\n  };\n  /**\n   * Consider some method like `filter`, `map` need make new data,\n   * We should make sure that `seriesModel.getData()` get correct\n   * data in the stream procedure. So we fetch data from upstream\n   * each time `task.perform` called.\n   */\n\n\n  SeriesModel.prototype.getData = function (dataType) {\n    var task = getCurrentTask(this);\n\n    if (task) {\n      var data = task.context.data;\n      return dataType == null ? data : data.getLinkedData(dataType);\n    } else {\n      // When series is not alive (that may happen when click toolbox\n      // restore or setOption with not merge mode), series data may\n      // be still need to judge animation or something when graphic\n      // elements want to know whether fade out.\n      return inner(this).data;\n    }\n  };\n\n  SeriesModel.prototype.getAllData = function () {\n    var mainData = this.getData();\n    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{\n      data: mainData\n    }];\n  };\n\n  SeriesModel.prototype.setData = function (data) {\n    var task = getCurrentTask(this);\n\n    if (task) {\n      var context = task.context; // Consider case: filter, data sample.\n      // FIXME:TS never used, so comment it\n      // if (context.data !== data && task.modifyOutputEnd) {\n      //     task.setOutputEnd(data.count());\n      // }\n\n      context.outputData = data; // Caution: setData should update context.data,\n      // Because getData may be called multiply in a\n      // single stage and expect to get the data just\n      // set. (For example, AxisProxy, x y both call\n      // getData and setDate sequentially).\n      // So the context.data should be fetched from\n      // upstream each time when a stage starts to be\n      // performed.\n\n      if (task !== this.dataTask) {\n        context.data = data;\n      }\n    }\n\n    inner(this).data = data;\n  };\n\n  SeriesModel.prototype.getSource = function () {\n    return inner(this).sourceManager.getSource();\n  };\n  /**\n   * Get data before processed\n   */\n\n\n  SeriesModel.prototype.getRawData = function () {\n    return inner(this).dataBeforeProcessed;\n  };\n  /**\n   * Get base axis if has coordinate system and has axis.\n   * By default use coordSys.getBaseAxis();\n   * Can be overrided for some chart.\n   * @return {type} description\n   */\n\n\n  SeriesModel.prototype.getBaseAxis = function () {\n    var coordSys = this.coordinateSystem; // @ts-ignore\n\n    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n  };\n  /**\n   * Default tooltip formatter\n   *\n   * @param dataIndex\n   * @param multipleSeries\n   * @param dataType\n   * @param renderMode valid values: 'html'(by default) and 'richText'.\n   *        'html' is used for rendering tooltip in extra DOM form, and the result\n   *        string is used as DOM HTML content.\n   *        'richText' is used for rendering tooltip in rich text form, for those where\n   *        DOM operation is not supported.\n   * @return formatted tooltip with `html` and `markers`\n   *        Notice: The override method can also return string\n   */\n\n\n  SeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    return defaultSeriesFormatTooltip({\n      series: this,\n      dataIndex: dataIndex,\n      multipleSeries: multipleSeries\n    });\n  };\n\n  SeriesModel.prototype.isAnimationEnabled = function () {\n    if (env.node) {\n      return false;\n    }\n\n    var animationEnabled = this.getShallow('animation');\n\n    if (animationEnabled) {\n      if (this.getData().count() > this.getShallow('animationThreshold')) {\n        animationEnabled = false;\n      }\n    }\n\n    return !!animationEnabled;\n  };\n\n  SeriesModel.prototype.restoreData = function () {\n    this.dataTask.dirty();\n  };\n\n  SeriesModel.prototype.getColorFromPalette = function (name, scope, requestColorNum) {\n    var ecModel = this.ecModel; // PENDING\n\n    var color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);\n\n    if (!color) {\n      color = ecModel.getColorFromPalette(name, scope, requestColorNum);\n    }\n\n    return color;\n  };\n  /**\n   * Use `data.mapDimensionsAll(coordDim)` instead.\n   * @deprecated\n   */\n\n\n  SeriesModel.prototype.coordDimToDataDim = function (coordDim) {\n    return this.getRawData().mapDimensionsAll(coordDim);\n  };\n  /**\n   * Get progressive rendering count each step\n   */\n\n\n  SeriesModel.prototype.getProgressive = function () {\n    return this.get('progressive');\n  };\n  /**\n   * Get progressive rendering count each step\n   */\n\n\n  SeriesModel.prototype.getProgressiveThreshold = function () {\n    return this.get('progressiveThreshold');\n  }; // PENGING If selectedMode is null ?\n\n\n  SeriesModel.prototype.select = function (innerDataIndices, dataType) {\n    this._innerSelect(this.getData(dataType), innerDataIndices);\n  };\n\n  SeriesModel.prototype.unselect = function (innerDataIndices, dataType) {\n    var selectedMap = this.option.selectedMap;\n\n    if (!selectedMap) {\n      return;\n    }\n\n    var data = this.getData(dataType);\n\n    for (var i = 0; i < innerDataIndices.length; i++) {\n      var dataIndex = innerDataIndices[i];\n      var nameOrId = getSelectionKey(data, dataIndex);\n      selectedMap[nameOrId] = false;\n      this._selectedDataIndicesMap[nameOrId] = -1;\n    }\n  };\n\n  SeriesModel.prototype.toggleSelect = function (innerDataIndices, dataType) {\n    var tmpArr = [];\n\n    for (var i = 0; i < innerDataIndices.length; i++) {\n      tmpArr[0] = innerDataIndices[i];\n      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);\n    }\n  };\n\n  SeriesModel.prototype.getSelectedDataIndices = function () {\n    var selectedDataIndicesMap = this._selectedDataIndicesMap;\n    var nameOrIds = zrUtil.keys(selectedDataIndicesMap);\n    var dataIndices = [];\n\n    for (var i = 0; i < nameOrIds.length; i++) {\n      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];\n\n      if (dataIndex >= 0) {\n        dataIndices.push(dataIndex);\n      }\n    }\n\n    return dataIndices;\n  };\n\n  SeriesModel.prototype.isSelected = function (dataIndex, dataType) {\n    var selectedMap = this.option.selectedMap;\n\n    if (!selectedMap) {\n      return false;\n    }\n\n    var data = this.getData(dataType);\n    var nameOrId = getSelectionKey(data, dataIndex);\n    return selectedMap[nameOrId] || false;\n  };\n\n  SeriesModel.prototype._innerSelect = function (data, innerDataIndices) {\n    var _a, _b;\n\n    var selectedMode = this.option.selectedMode;\n    var len = innerDataIndices.length;\n\n    if (!selectedMode || !len) {\n      return;\n    }\n\n    if (selectedMode === 'multiple') {\n      var selectedMap = this.option.selectedMap || (this.option.selectedMap = {});\n\n      for (var i = 0; i < len; i++) {\n        var dataIndex = innerDataIndices[i]; // TODO diffrent types of data share same object.\n\n        var nameOrId = getSelectionKey(data, dataIndex);\n        selectedMap[nameOrId] = true;\n        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);\n      }\n    } else if (selectedMode === 'single' || selectedMode === true) {\n      var lastDataIndex = innerDataIndices[len - 1];\n      var nameOrId = getSelectionKey(data, lastDataIndex);\n      this.option.selectedMap = (_a = {}, _a[nameOrId] = true, _a);\n      this._selectedDataIndicesMap = (_b = {}, _b[nameOrId] = data.getRawIndex(lastDataIndex), _b);\n    }\n  };\n\n  SeriesModel.prototype._initSelectedMapFromData = function (data) {\n    // Ignore select info in data if selectedMap exists.\n    // NOTE It's only for legacy usage. edge data is not supported.\n    if (this.option.selectedMap) {\n      return;\n    }\n\n    var dataIndices = [];\n\n    if (data.hasItemOption) {\n      data.each(function (idx) {\n        var rawItem = data.getRawDataItem(idx);\n\n        if (typeof rawItem === 'object' && rawItem.selected) {\n          dataIndices.push(idx);\n        }\n      });\n    }\n\n    if (dataIndices.length > 0) {\n      this._innerSelect(data, dataIndices);\n    }\n  }; // /**\n  //  * @see {module:echarts/stream/Scheduler}\n  //  */\n  // abstract pipeTask: null\n\n\n  SeriesModel.registerClass = function (clz) {\n    return ComponentModel.registerClass(clz);\n  };\n\n  SeriesModel.protoInitialize = function () {\n    var proto = SeriesModel.prototype;\n    proto.type = 'series.__base__';\n    proto.seriesIndex = 0;\n    proto.useColorPaletteOnData = false;\n    proto.ignoreStyleOnData = false;\n    proto.hasSymbolVisual = false;\n    proto.defaultSymbol = 'circle'; // Make sure the values can be accessed!\n\n    proto.visualStyleAccessPath = 'itemStyle';\n    proto.visualDrawType = 'fill';\n  }();\n\n  return SeriesModel;\n}(ComponentModel);\n\nzrUtil.mixin(SeriesModel, DataFormatMixin);\nzrUtil.mixin(SeriesModel, PaletteMixin);\nmountExtend(SeriesModel, ComponentModel);\n/**\n * MUST be called after `prepareSource` called\n * Here we need to make auto series, especially for auto legend. But we\n * do not modify series.name in option to avoid side effects.\n */\n\nfunction autoSeriesName(seriesModel) {\n  // User specified name has higher priority, otherwise it may cause\n  // series can not be queried unexpectedly.\n  var name = seriesModel.name;\n\n  if (!modelUtil.isNameSpecified(seriesModel)) {\n    seriesModel.name = getSeriesAutoName(seriesModel) || name;\n  }\n}\n\nfunction getSeriesAutoName(seriesModel) {\n  var data = seriesModel.getRawData();\n  var dataDims = data.mapDimensionsAll('seriesName');\n  var nameArr = [];\n  zrUtil.each(dataDims, function (dataDim) {\n    var dimInfo = data.getDimensionInfo(dataDim);\n    dimInfo.displayName && nameArr.push(dimInfo.displayName);\n  });\n  return nameArr.join(' ');\n}\n\nfunction dataTaskCount(context) {\n  return context.model.getRawData().count();\n}\n\nfunction dataTaskReset(context) {\n  var seriesModel = context.model;\n  seriesModel.setData(seriesModel.getRawData().cloneShallow());\n  return dataTaskProgress;\n}\n\nfunction dataTaskProgress(param, context) {\n  // Avoid repead cloneShallow when data just created in reset.\n  if (context.outputData && param.end > context.outputData.count()) {\n    context.model.getRawData().cloneShallow(context.outputData);\n  }\n} // TODO refactor\n\n\nfunction wrapData(data, seriesModel) {\n  zrUtil.each(__spreadArrays(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function (methodName) {\n    data.wrapMethod(methodName, zrUtil.curry(onDataChange, seriesModel));\n  });\n}\n\nfunction onDataChange(seriesModel, newList) {\n  var task = getCurrentTask(seriesModel);\n\n  if (task) {\n    // Consider case: filter, selectRange\n    task.setOutputEnd((newList || this).count());\n  }\n\n  return newList;\n}\n\nfunction getCurrentTask(seriesModel) {\n  var scheduler = (seriesModel.ecModel || {}).scheduler;\n  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);\n\n  if (pipeline) {\n    // When pipline finished, the currrentTask keep the last\n    // task (renderTask).\n    var task = pipeline.currentTask;\n\n    if (task) {\n      var agentStubMap = task.agentStubMap;\n\n      if (agentStubMap) {\n        task = agentStubMap.get(seriesModel.uid);\n      }\n    }\n\n    return task;\n  }\n}\n\nexport default SeriesModel;","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/echarts/lib/model/Series.js"],"names":["__extends","__spreadArrays","zrUtil","env","modelUtil","ComponentModel","PaletteMixin","DataFormatMixin","getLayoutParams","mergeLayoutParam","fetchLayoutMode","createTask","mountExtend","SourceManager","defaultSeriesFormatTooltip","inner","makeInner","getSelectionKey","data","dataIndex","getName","getId","SeriesModel","_super","_this","apply","arguments","_selectedDataIndicesMap","prototype","init","option","parentModel","ecModel","seriesIndex","componentIndex","dataTask","count","dataTaskCount","reset","dataTaskReset","context","model","mergeDefaultAndTheme","sourceManager","prepareSource","getInitialData","wrapData","process","NODE_ENV","assert","dataBeforeProcessed","autoSeriesName","_initSelectedMapFromData","layoutMode","inputPositionParams","themeSubType","subType","hasClass","merge","getTheme","get","getDefaultOption","defaultEmphasis","fillDataTextStyle","mergeOption","newSeriesOption","dirty","isTypedArray","props","i","length","label","appendData","params","getRawData","getData","dataType","task","getCurrentTask","getLinkedData","getAllData","mainData","getLinkedDataAll","setData","outputData","getSource","getBaseAxis","coordSys","coordinateSystem","formatTooltip","multipleSeries","series","isAnimationEnabled","node","animationEnabled","getShallow","restoreData","getColorFromPalette","name","scope","requestColorNum","color","call","coordDimToDataDim","coordDim","mapDimensionsAll","getProgressive","getProgressiveThreshold","select","innerDataIndices","_innerSelect","unselect","selectedMap","nameOrId","toggleSelect","tmpArr","isSelected","getSelectedDataIndices","selectedDataIndicesMap","nameOrIds","keys","dataIndices","push","_a","_b","selectedMode","len","getRawIndex","lastDataIndex","hasItemOption","each","idx","rawItem","getRawDataItem","selected","registerClass","clz","protoInitialize","proto","type","useColorPaletteOnData","ignoreStyleOnData","hasSymbolVisual","defaultSymbol","visualStyleAccessPath","visualDrawType","mixin","seriesModel","isNameSpecified","getSeriesAutoName","dataDims","nameArr","dataDim","dimInfo","getDimensionInfo","displayName","join","cloneShallow","dataTaskProgress","param","end","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","methodName","wrapMethod","curry","onDataChange","newList","setOutputEnd","scheduler","pipeline","getPipeline","uid","currentTask","agentStubMap"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends, __spreadArrays } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util';\nimport env from 'zrender/lib/core/env';\nimport * as modelUtil from '../util/model';\nimport ComponentModel from './Component';\nimport { PaletteMixin } from './mixin/palette';\nimport { DataFormatMixin } from '../model/mixin/dataFormat';\nimport { getLayoutParams, mergeLayoutParam, fetchLayoutMode } from '../util/layout';\nimport { createTask } from '../core/task';\nimport { mountExtend } from '../util/clazz';\nimport { SourceManager } from '../data/helper/sourceManager';\nimport { defaultSeriesFormatTooltip } from '../component/tooltip/seriesFormatTooltip';\nvar inner = modelUtil.makeInner();\n\nfunction getSelectionKey(data, dataIndex) {\n  return data.getName(dataIndex) || data.getId(dataIndex);\n}\n\nvar SeriesModel =\n/** @class */\nfunction (_super) {\n  __extends(SeriesModel, _super);\n\n  function SeriesModel() {\n    // [Caution]: Becuase this class or desecendants can be used as `XXX.extend(subProto)`,\n    // the class members must not be initialized in constructor or declaration place.\n    // Otherwise there is bad case:\n    //   class A {xxx = 1;}\n    //   enableClassExtend(A);\n    //   class B extends A {}\n    //   var C = B.extend({xxx: 5});\n    //   var c = new C();\n    //   console.log(c.xxx); // expect 5 but always 1.\n    var _this = _super !== null && _super.apply(this, arguments) || this; // ---------------------------------------\n    // Props about data selection\n    // ---------------------------------------\n\n\n    _this._selectedDataIndicesMap = {};\n    return _this;\n  }\n\n  SeriesModel.prototype.init = function (option, parentModel, ecModel) {\n    this.seriesIndex = this.componentIndex;\n    this.dataTask = createTask({\n      count: dataTaskCount,\n      reset: dataTaskReset\n    });\n    this.dataTask.context = {\n      model: this\n    };\n    this.mergeDefaultAndTheme(option, ecModel);\n    var sourceManager = inner(this).sourceManager = new SourceManager(this);\n    sourceManager.prepareSource();\n    var data = this.getInitialData(option, ecModel);\n    wrapData(data, this);\n    this.dataTask.context.data = data;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(data, 'getInitialData returned invalid data.');\n    }\n\n    inner(this).dataBeforeProcessed = data; // If we reverse the order (make data firstly, and then make\n    // dataBeforeProcessed by cloneShallow), cloneShallow will\n    // cause data.graph.data !== data when using\n    // module:echarts/data/Graph or module:echarts/data/Tree.\n    // See module:echarts/data/helper/linkList\n    // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model\n    // init or merge stage, because the data can be restored. So we do not `restoreData`\n    // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.\n    // Call `seriesModel.getRawData()` instead.\n    // this.restoreData();\n\n    autoSeriesName(this);\n\n    this._initSelectedMapFromData(data);\n  };\n  /**\n   * Util for merge default and theme to option\n   */\n\n\n  SeriesModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n    var layoutMode = fetchLayoutMode(this);\n    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.\n    // But if name duplicate between series subType\n    // (for example: parallel) add component mainType,\n    // add suffix 'Series'.\n\n    var themeSubType = this.subType;\n\n    if (ComponentModel.hasClass(themeSubType)) {\n      themeSubType += 'Series';\n    }\n\n    zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`\n\n    modelUtil.defaultEmphasis(option, 'label', ['show']);\n    this.fillDataTextStyle(option.data);\n\n    if (layoutMode) {\n      mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  };\n\n  SeriesModel.prototype.mergeOption = function (newSeriesOption, ecModel) {\n    // this.settingTask.dirty();\n    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n    this.fillDataTextStyle(newSeriesOption.data);\n    var layoutMode = fetchLayoutMode(this);\n\n    if (layoutMode) {\n      mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n    }\n\n    var sourceManager = inner(this).sourceManager;\n    sourceManager.dirty();\n    sourceManager.prepareSource();\n    var data = this.getInitialData(newSeriesOption, ecModel);\n    wrapData(data, this);\n    this.dataTask.dirty();\n    this.dataTask.context.data = data;\n    inner(this).dataBeforeProcessed = data;\n    autoSeriesName(this);\n\n    this._initSelectedMapFromData(data);\n  };\n\n  SeriesModel.prototype.fillDataTextStyle = function (data) {\n    // Default data label emphasis `show`\n    // FIXME Tree structure data ?\n    // FIXME Performance ?\n    if (data && !zrUtil.isTypedArray(data)) {\n      var props = ['show'];\n\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] && data[i].label) {\n          modelUtil.defaultEmphasis(data[i], 'label', props);\n        }\n      }\n    }\n  };\n  /**\n   * Init a data structure from data related option in series\n   * Must be overriden.\n   */\n\n\n  SeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return;\n  };\n  /**\n   * Append data to list\n   */\n\n\n  SeriesModel.prototype.appendData = function (params) {\n    // FIXME ???\n    // (1) If data from dataset, forbidden append.\n    // (2) support append data of dataset.\n    var data = this.getRawData();\n    data.appendData(params.data);\n  };\n  /**\n   * Consider some method like `filter`, `map` need make new data,\n   * We should make sure that `seriesModel.getData()` get correct\n   * data in the stream procedure. So we fetch data from upstream\n   * each time `task.perform` called.\n   */\n\n\n  SeriesModel.prototype.getData = function (dataType) {\n    var task = getCurrentTask(this);\n\n    if (task) {\n      var data = task.context.data;\n      return dataType == null ? data : data.getLinkedData(dataType);\n    } else {\n      // When series is not alive (that may happen when click toolbox\n      // restore or setOption with not merge mode), series data may\n      // be still need to judge animation or something when graphic\n      // elements want to know whether fade out.\n      return inner(this).data;\n    }\n  };\n\n  SeriesModel.prototype.getAllData = function () {\n    var mainData = this.getData();\n    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{\n      data: mainData\n    }];\n  };\n\n  SeriesModel.prototype.setData = function (data) {\n    var task = getCurrentTask(this);\n\n    if (task) {\n      var context = task.context; // Consider case: filter, data sample.\n      // FIXME:TS never used, so comment it\n      // if (context.data !== data && task.modifyOutputEnd) {\n      //     task.setOutputEnd(data.count());\n      // }\n\n      context.outputData = data; // Caution: setData should update context.data,\n      // Because getData may be called multiply in a\n      // single stage and expect to get the data just\n      // set. (For example, AxisProxy, x y both call\n      // getData and setDate sequentially).\n      // So the context.data should be fetched from\n      // upstream each time when a stage starts to be\n      // performed.\n\n      if (task !== this.dataTask) {\n        context.data = data;\n      }\n    }\n\n    inner(this).data = data;\n  };\n\n  SeriesModel.prototype.getSource = function () {\n    return inner(this).sourceManager.getSource();\n  };\n  /**\n   * Get data before processed\n   */\n\n\n  SeriesModel.prototype.getRawData = function () {\n    return inner(this).dataBeforeProcessed;\n  };\n  /**\n   * Get base axis if has coordinate system and has axis.\n   * By default use coordSys.getBaseAxis();\n   * Can be overrided for some chart.\n   * @return {type} description\n   */\n\n\n  SeriesModel.prototype.getBaseAxis = function () {\n    var coordSys = this.coordinateSystem; // @ts-ignore\n\n    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n  };\n  /**\n   * Default tooltip formatter\n   *\n   * @param dataIndex\n   * @param multipleSeries\n   * @param dataType\n   * @param renderMode valid values: 'html'(by default) and 'richText'.\n   *        'html' is used for rendering tooltip in extra DOM form, and the result\n   *        string is used as DOM HTML content.\n   *        'richText' is used for rendering tooltip in rich text form, for those where\n   *        DOM operation is not supported.\n   * @return formatted tooltip with `html` and `markers`\n   *        Notice: The override method can also return string\n   */\n\n\n  SeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    return defaultSeriesFormatTooltip({\n      series: this,\n      dataIndex: dataIndex,\n      multipleSeries: multipleSeries\n    });\n  };\n\n  SeriesModel.prototype.isAnimationEnabled = function () {\n    if (env.node) {\n      return false;\n    }\n\n    var animationEnabled = this.getShallow('animation');\n\n    if (animationEnabled) {\n      if (this.getData().count() > this.getShallow('animationThreshold')) {\n        animationEnabled = false;\n      }\n    }\n\n    return !!animationEnabled;\n  };\n\n  SeriesModel.prototype.restoreData = function () {\n    this.dataTask.dirty();\n  };\n\n  SeriesModel.prototype.getColorFromPalette = function (name, scope, requestColorNum) {\n    var ecModel = this.ecModel; // PENDING\n\n    var color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);\n\n    if (!color) {\n      color = ecModel.getColorFromPalette(name, scope, requestColorNum);\n    }\n\n    return color;\n  };\n  /**\n   * Use `data.mapDimensionsAll(coordDim)` instead.\n   * @deprecated\n   */\n\n\n  SeriesModel.prototype.coordDimToDataDim = function (coordDim) {\n    return this.getRawData().mapDimensionsAll(coordDim);\n  };\n  /**\n   * Get progressive rendering count each step\n   */\n\n\n  SeriesModel.prototype.getProgressive = function () {\n    return this.get('progressive');\n  };\n  /**\n   * Get progressive rendering count each step\n   */\n\n\n  SeriesModel.prototype.getProgressiveThreshold = function () {\n    return this.get('progressiveThreshold');\n  }; // PENGING If selectedMode is null ?\n\n\n  SeriesModel.prototype.select = function (innerDataIndices, dataType) {\n    this._innerSelect(this.getData(dataType), innerDataIndices);\n  };\n\n  SeriesModel.prototype.unselect = function (innerDataIndices, dataType) {\n    var selectedMap = this.option.selectedMap;\n\n    if (!selectedMap) {\n      return;\n    }\n\n    var data = this.getData(dataType);\n\n    for (var i = 0; i < innerDataIndices.length; i++) {\n      var dataIndex = innerDataIndices[i];\n      var nameOrId = getSelectionKey(data, dataIndex);\n      selectedMap[nameOrId] = false;\n      this._selectedDataIndicesMap[nameOrId] = -1;\n    }\n  };\n\n  SeriesModel.prototype.toggleSelect = function (innerDataIndices, dataType) {\n    var tmpArr = [];\n\n    for (var i = 0; i < innerDataIndices.length; i++) {\n      tmpArr[0] = innerDataIndices[i];\n      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);\n    }\n  };\n\n  SeriesModel.prototype.getSelectedDataIndices = function () {\n    var selectedDataIndicesMap = this._selectedDataIndicesMap;\n    var nameOrIds = zrUtil.keys(selectedDataIndicesMap);\n    var dataIndices = [];\n\n    for (var i = 0; i < nameOrIds.length; i++) {\n      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];\n\n      if (dataIndex >= 0) {\n        dataIndices.push(dataIndex);\n      }\n    }\n\n    return dataIndices;\n  };\n\n  SeriesModel.prototype.isSelected = function (dataIndex, dataType) {\n    var selectedMap = this.option.selectedMap;\n\n    if (!selectedMap) {\n      return false;\n    }\n\n    var data = this.getData(dataType);\n    var nameOrId = getSelectionKey(data, dataIndex);\n    return selectedMap[nameOrId] || false;\n  };\n\n  SeriesModel.prototype._innerSelect = function (data, innerDataIndices) {\n    var _a, _b;\n\n    var selectedMode = this.option.selectedMode;\n    var len = innerDataIndices.length;\n\n    if (!selectedMode || !len) {\n      return;\n    }\n\n    if (selectedMode === 'multiple') {\n      var selectedMap = this.option.selectedMap || (this.option.selectedMap = {});\n\n      for (var i = 0; i < len; i++) {\n        var dataIndex = innerDataIndices[i]; // TODO diffrent types of data share same object.\n\n        var nameOrId = getSelectionKey(data, dataIndex);\n        selectedMap[nameOrId] = true;\n        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);\n      }\n    } else if (selectedMode === 'single' || selectedMode === true) {\n      var lastDataIndex = innerDataIndices[len - 1];\n      var nameOrId = getSelectionKey(data, lastDataIndex);\n      this.option.selectedMap = (_a = {}, _a[nameOrId] = true, _a);\n      this._selectedDataIndicesMap = (_b = {}, _b[nameOrId] = data.getRawIndex(lastDataIndex), _b);\n    }\n  };\n\n  SeriesModel.prototype._initSelectedMapFromData = function (data) {\n    // Ignore select info in data if selectedMap exists.\n    // NOTE It's only for legacy usage. edge data is not supported.\n    if (this.option.selectedMap) {\n      return;\n    }\n\n    var dataIndices = [];\n\n    if (data.hasItemOption) {\n      data.each(function (idx) {\n        var rawItem = data.getRawDataItem(idx);\n\n        if (typeof rawItem === 'object' && rawItem.selected) {\n          dataIndices.push(idx);\n        }\n      });\n    }\n\n    if (dataIndices.length > 0) {\n      this._innerSelect(data, dataIndices);\n    }\n  }; // /**\n  //  * @see {module:echarts/stream/Scheduler}\n  //  */\n  // abstract pipeTask: null\n\n\n  SeriesModel.registerClass = function (clz) {\n    return ComponentModel.registerClass(clz);\n  };\n\n  SeriesModel.protoInitialize = function () {\n    var proto = SeriesModel.prototype;\n    proto.type = 'series.__base__';\n    proto.seriesIndex = 0;\n    proto.useColorPaletteOnData = false;\n    proto.ignoreStyleOnData = false;\n    proto.hasSymbolVisual = false;\n    proto.defaultSymbol = 'circle'; // Make sure the values can be accessed!\n\n    proto.visualStyleAccessPath = 'itemStyle';\n    proto.visualDrawType = 'fill';\n  }();\n\n  return SeriesModel;\n}(ComponentModel);\n\nzrUtil.mixin(SeriesModel, DataFormatMixin);\nzrUtil.mixin(SeriesModel, PaletteMixin);\nmountExtend(SeriesModel, ComponentModel);\n/**\n * MUST be called after `prepareSource` called\n * Here we need to make auto series, especially for auto legend. But we\n * do not modify series.name in option to avoid side effects.\n */\n\nfunction autoSeriesName(seriesModel) {\n  // User specified name has higher priority, otherwise it may cause\n  // series can not be queried unexpectedly.\n  var name = seriesModel.name;\n\n  if (!modelUtil.isNameSpecified(seriesModel)) {\n    seriesModel.name = getSeriesAutoName(seriesModel) || name;\n  }\n}\n\nfunction getSeriesAutoName(seriesModel) {\n  var data = seriesModel.getRawData();\n  var dataDims = data.mapDimensionsAll('seriesName');\n  var nameArr = [];\n  zrUtil.each(dataDims, function (dataDim) {\n    var dimInfo = data.getDimensionInfo(dataDim);\n    dimInfo.displayName && nameArr.push(dimInfo.displayName);\n  });\n  return nameArr.join(' ');\n}\n\nfunction dataTaskCount(context) {\n  return context.model.getRawData().count();\n}\n\nfunction dataTaskReset(context) {\n  var seriesModel = context.model;\n  seriesModel.setData(seriesModel.getRawData().cloneShallow());\n  return dataTaskProgress;\n}\n\nfunction dataTaskProgress(param, context) {\n  // Avoid repead cloneShallow when data just created in reset.\n  if (context.outputData && param.end > context.outputData.count()) {\n    context.model.getRawData().cloneShallow(context.outputData);\n  }\n} // TODO refactor\n\n\nfunction wrapData(data, seriesModel) {\n  zrUtil.each(__spreadArrays(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function (methodName) {\n    data.wrapMethod(methodName, zrUtil.curry(onDataChange, seriesModel));\n  });\n}\n\nfunction onDataChange(seriesModel, newList) {\n  var task = getCurrentTask(seriesModel);\n\n  if (task) {\n    // Consider case: filter, selectRange\n    task.setOutputEnd((newList || this).count());\n  }\n\n  return newList;\n}\n\nfunction getCurrentTask(seriesModel) {\n  var scheduler = (seriesModel.ecModel || {}).scheduler;\n  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);\n\n  if (pipeline) {\n    // When pipline finished, the currrentTask keep the last\n    // task (renderTask).\n    var task = pipeline.currentTask;\n\n    if (task) {\n      var agentStubMap = task.agentStubMap;\n\n      if (agentStubMap) {\n        task = agentStubMap.get(seriesModel.uid);\n      }\n    }\n\n    return task;\n  }\n}\n\nexport default SeriesModel;"]},"metadata":{},"sourceType":"module"}