{"ast":null,"code":"const Blockchain = {\n  getBlockByNumber(blockNumber, provider, callback) {\n    const params = [blockNumber, true];\n    provider.send({\n      jsonrpc: \"2.0\",\n      method: \"eth_getBlockByNumber\",\n      params,\n      id: Date.now()\n    }, callback);\n  },\n\n  getBlockByHash(blockHash, provider, callback) {\n    const params = [blockHash, true];\n    provider.send({\n      jsonrpc: \"2.0\",\n      method: \"eth_getBlockByHash\",\n      params,\n      id: Date.now()\n    }, callback);\n  },\n\n  parse(uri) {\n    const parsed = {};\n    if (uri.indexOf(\"blockchain://\") !== 0) return parsed;\n    const cleanUri = uri.replace(\"blockchain://\", \"\");\n    const pieces = cleanUri.split(\"/block/\");\n    parsed.genesis_hash = `0x${pieces[0]}`;\n    parsed.block_hash = `0x${pieces[1]}`;\n    return parsed;\n  },\n\n  asURI(provider, callback) {\n    let genesis, latest;\n    this.getBlockByNumber(\"0x0\", provider, (err, {\n      result\n    }) => {\n      if (err) return callback(err);\n      genesis = result;\n      this.getBlockByNumber(\"latest\", provider, (err, {\n        result\n      }) => {\n        if (err) return callback(err);\n        latest = result;\n        const url = `blockchain://${genesis.hash.replace(\"0x\", \"\")}/block/${latest.hash.replace(\"0x\", \"\")}`;\n        callback(null, url);\n      });\n    });\n  },\n\n  matches(uri, provider, callback) {\n    const parsedUri = this.parse(uri);\n    const expected_genesis = parsedUri.genesis_hash;\n    const expected_block = parsedUri.block_hash;\n    this.getBlockByNumber(\"0x0\", provider, (err, {\n      result\n    }) => {\n      if (err) return callback(err);\n      const block = result;\n      if (block.hash !== expected_genesis) return callback(null, false);\n      this.getBlockByHash(expected_block, provider, (err, {\n        result\n      }) => {\n        // Treat an error as if the block didn't exist. This is because\n        // some clients respond differently.\n        const block = result;\n\n        if (err || block == null) {\n          return callback(null, false);\n        }\n\n        callback(null, true);\n      });\n    });\n  }\n\n};\nmodule.exports = Blockchain;","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/@truffle/blockchain-utils/index.js"],"names":["Blockchain","getBlockByNumber","blockNumber","provider","callback","params","send","jsonrpc","method","id","Date","now","getBlockByHash","blockHash","parse","uri","parsed","indexOf","cleanUri","replace","pieces","split","genesis_hash","block_hash","asURI","genesis","latest","err","result","url","hash","matches","parsedUri","expected_genesis","expected_block","block","module","exports"],"mappings":"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","sourcesContent":["const Blockchain = {\n  getBlockByNumber(blockNumber, provider, callback) {\n    const params = [blockNumber, true];\n    provider.send(\n      {\n        jsonrpc: \"2.0\",\n        method: \"eth_getBlockByNumber\",\n        params,\n        id: Date.now()\n      },\n      callback\n    );\n  },\n\n  getBlockByHash(blockHash, provider, callback) {\n    const params = [blockHash, true];\n    provider.send(\n      {\n        jsonrpc: \"2.0\",\n        method: \"eth_getBlockByHash\",\n        params,\n        id: Date.now()\n      },\n      callback\n    );\n  },\n\n  parse(uri) {\n    const parsed = {};\n    if (uri.indexOf(\"blockchain://\") !== 0) return parsed;\n\n    const cleanUri = uri.replace(\"blockchain://\", \"\");\n\n    const pieces = cleanUri.split(\"/block/\");\n\n    parsed.genesis_hash = `0x${pieces[0]}`;\n    parsed.block_hash = `0x${pieces[1]}`;\n\n    return parsed;\n  },\n\n  asURI(provider, callback) {\n    let genesis, latest;\n\n    this.getBlockByNumber(\"0x0\", provider, (err, { result }) => {\n      if (err) return callback(err);\n      genesis = result;\n\n      this.getBlockByNumber(\"latest\", provider, (err, { result }) => {\n        if (err) return callback(err);\n        latest = result;\n        const url = `blockchain://${genesis.hash.replace(\n          \"0x\",\n          \"\"\n        )}/block/${latest.hash.replace(\"0x\", \"\")}`;\n        callback(null, url);\n      });\n    });\n  },\n\n  matches(uri, provider, callback) {\n    const parsedUri = this.parse(uri);\n\n    const expected_genesis = parsedUri.genesis_hash;\n    const expected_block = parsedUri.block_hash;\n\n    this.getBlockByNumber(\"0x0\", provider, (err, { result }) => {\n      if (err) return callback(err);\n      const block = result;\n      if (block.hash !== expected_genesis) return callback(null, false);\n\n      this.getBlockByHash(expected_block, provider, (err, { result }) => {\n        // Treat an error as if the block didn't exist. This is because\n        // some clients respond differently.\n        const block = result;\n        if (err || block == null) {\n          return callback(null, false);\n        }\n\n        callback(null, true);\n      });\n    });\n  }\n};\n\nmodule.exports = Blockchain;\n"]},"metadata":{},"sourceType":"script"}