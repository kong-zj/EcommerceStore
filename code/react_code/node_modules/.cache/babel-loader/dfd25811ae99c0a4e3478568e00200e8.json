{"ast":null,"code":"const Web3Shim = require(\"truffle-interface-adapter\").Web3Shim;\n\nconst utils = require(\"../utils\");\n\nconst execute = require(\"../execute\");\n\nconst bootstrap = require(\"./bootstrap\");\n\nmodule.exports = Contract => ({\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(`Invalid provider passed to setProvider(); provider is ${provider}`);\n    }\n\n    this.web3.setProvider(provider);\n    this.currentProvider = provider;\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(`${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` + `This contract may be abstract, not implement an abstract parent's methods completely\\n` + `or not invoke an inherited contract's constructor correctly\\n`);\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (address == null || typeof address !== \"string\" || address.length !== 42) {\n      throw new Error(`Invalid address passed to ${this.contractName}.at(): ${address}`);\n    }\n\n    try {\n      await this.detectNetwork();\n      const onChainCode = await this.web3.eth.getCode(address);\n      await utils.checkCode(onChainCode, this.contractName, address);\n      return new this(address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  async deployed() {\n    try {\n      utils.checkProvider(this);\n      await this.detectNetwork();\n      utils.checkNetworkArtifactMatch(this);\n      utils.checkDeployment(this);\n      return new this(this.address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      try {\n        const {\n          gasLimit\n        } = await this.web3.eth.getBlock(\"latest\");\n        return {\n          id: this.network_id,\n          blockLimit: gasLimit\n        };\n      } catch (error) {\n        throw error;\n      }\n    } // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n\n\n    try {\n      const chainNetworkID = await this.web3.eth.net.getId();\n      const {\n        gasLimit\n      } = await this.web3.eth.getBlock(\"latest\");\n      return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType(networkType = \"ethereum\") {\n    if (this.web3) {\n      this.web3.setNetworkType(networkType);\n    }\n\n    this.networkType = networkType;\n  },\n\n  setWallet(wallet) {\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  link(name, address) {\n    // Case: Contract.link(instance)\n    if (typeof name === \"function\") {\n      const contract = name;\n\n      if (contract.isDeployed() === false) {\n        throw new Error(\"Cannot link contract without an address.\");\n      }\n\n      this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n      Object.keys(contract.events).forEach(topic => {\n        this.network.events[topic] = contract.events[topic];\n      });\n      return;\n    } // Case: Contract.link({<libraryName>: <address>, ... })\n\n\n    if (typeof name === \"object\") {\n      const obj = name;\n      Object.keys(obj).forEach(name => {\n        const a = obj[name];\n        this.link(name, a);\n      });\n      return;\n    } // Case: Contract.link(<libraryName>, <address>)\n\n\n    if (this._json.networks[this.network_id] == null) {\n      this._json.networks[this.network_id] = {\n        events: {},\n        links: {}\n      };\n    }\n\n    this.network.links[name] = address;\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n    let network_id; // If we have a network id passed\n\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n    temp._property_values = {};\n    temp._json = json;\n    bootstrap(temp);\n    temp.web3 = new Web3Shim({\n      type: temp.networkType\n    });\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    } // Copy over custom key/values to the contract class\n\n\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      } // If there's not a setter, then the property is immutable.\n\n\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/truffle-contract/lib/contract/constructorMethods.js"],"names":["Web3Shim","require","utils","execute","bootstrap","module","exports","Contract","setProvider","provider","Error","web3","currentProvider","new","checkProvider","bytecode","contractName","constructorABI","abi","filter","i","type","deploy","call","arguments","at","address","length","detectNetwork","onChainCode","eth","getCode","checkCode","error","deployed","checkNetworkArtifactMatch","checkDeployment","defaults","class_defaults","Object","keys","forEach","key","value","hasNetwork","network_id","_json","networks","isDeployed","network","gasLimit","getBlock","id","blockLimit","chainNetworkID","net","getId","setInstanceNetworkID","setNetwork","setNetworkType","networkType","setWallet","wallet","accounts","resetAddress","link","name","contract","events","topic","obj","a","links","clone","json","temp","TruffleContract","constructor","apply","prototype","create","merge","_constructorMethods","_properties","_property_values","indexOf","addProp","fn","getter","get","setter","val","set","definition","enumerable","configurable","defineProperty","toJSON","decodeLogs"],"mappings":"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","sourcesContent":["const Web3Shim = require(\"truffle-interface-adapter\").Web3Shim;\nconst utils = require(\"../utils\");\nconst execute = require(\"../execute\");\nconst bootstrap = require(\"./bootstrap\");\n\nmodule.exports = Contract => ({\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(\n        `Invalid provider passed to setProvider(); provider is ${provider}`\n      );\n    }\n\n    this.web3.setProvider(provider);\n    this.currentProvider = provider;\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(\n        `${\n          this.contractName\n        } error: contract binary not set. Can't deploy new instance.\\n` +\n          `This contract may be abstract, not implement an abstract parent's methods completely\\n` +\n          `or not invoke an inherited contract's constructor correctly\\n`\n      );\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (\n      address == null ||\n      typeof address !== \"string\" ||\n      address.length !== 42\n    ) {\n      throw new Error(\n        `Invalid address passed to ${this.contractName}.at(): ${address}`\n      );\n    }\n\n    try {\n      await this.detectNetwork();\n      const onChainCode = await this.web3.eth.getCode(address);\n      await utils.checkCode(onChainCode, this.contractName, address);\n      return new this(address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  async deployed() {\n    try {\n      utils.checkProvider(this);\n      await this.detectNetwork();\n      utils.checkNetworkArtifactMatch(this);\n      utils.checkDeployment(this);\n      return new this(this.address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      try {\n        const { gasLimit } = await this.web3.eth.getBlock(\"latest\");\n        return { id: this.network_id, blockLimit: gasLimit };\n      } catch (error) {\n        throw error;\n      }\n    }\n    // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n    try {\n      const chainNetworkID = await this.web3.eth.net.getId();\n      const { gasLimit } = await this.web3.eth.getBlock(\"latest\");\n      return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType(networkType = \"ethereum\") {\n    if (this.web3) {\n      this.web3.setNetworkType(networkType);\n    }\n\n    this.networkType = networkType;\n  },\n\n  setWallet(wallet) {\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  link(name, address) {\n    // Case: Contract.link(instance)\n    if (typeof name === \"function\") {\n      const contract = name;\n\n      if (contract.isDeployed() === false) {\n        throw new Error(\"Cannot link contract without an address.\");\n      }\n\n      this.link(contract.contractName, contract.address);\n\n      // Merge events so this contract knows about library's events\n      Object.keys(contract.events).forEach(topic => {\n        this.network.events[topic] = contract.events[topic];\n      });\n\n      return;\n    }\n\n    // Case: Contract.link({<libraryName>: <address>, ... })\n    if (typeof name === \"object\") {\n      const obj = name;\n      Object.keys(obj).forEach(name => {\n        const a = obj[name];\n        this.link(name, a);\n      });\n      return;\n    }\n\n    // Case: Contract.link(<libraryName>, <address>)\n    if (this._json.networks[this.network_id] == null) {\n      this._json.networks[this.network_id] = {\n        events: {},\n        links: {}\n      };\n    }\n\n    this.network.links[name] = address;\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n\n    let network_id;\n\n    // If we have a network id passed\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n\n    temp._property_values = {};\n    temp._json = json;\n\n    bootstrap(temp);\n\n    temp.web3 = new Web3Shim({\n      type: temp.networkType\n    });\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n\n    // Copy over custom key/values to the contract class\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      }\n\n      // If there's not a setter, then the property is immutable.\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});\n"]},"metadata":{},"sourceType":"script"}