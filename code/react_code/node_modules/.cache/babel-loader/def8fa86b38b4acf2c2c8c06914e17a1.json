{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\"; // TODO Optimize on polar\n\nimport * as colorUtil from 'zrender/lib/tool/color';\nimport List from '../../data/List';\nimport * as numberUtil from '../../util/number';\nimport * as graphic from '../../util/graphic';\nimport { enableHoverEmphasis, setStatesStylesFromModel } from '../../util/states';\nimport * as markerHelper from './markerHelper';\nimport MarkerView from './MarkerView';\nimport { retrieve, mergeAll, map, defaults, curry, filter, each } from 'zrender/lib/core/util';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem';\nimport MarkerModel from './MarkerModel';\nimport { makeInner } from '../../util/model';\nimport { getVisualFromData } from '../../visual/helper';\nimport { setLabelStyle, getLabelStatesModels } from '../../label/labelStyle';\nimport { getECData } from '../../util/innerStore';\nvar inner = makeInner();\n\nvar markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n  var lt = markerHelper.dataTransform(seriesModel, item[0]);\n  var rb = markerHelper.dataTransform(seriesModel, item[1]); // FIXME make sure lt is less than rb\n\n  var ltCoord = lt.coord;\n  var rbCoord = rb.coord;\n  ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n  ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n  rbCoord[0] = retrieve(rbCoord[0], Infinity);\n  rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one\n\n  var result = mergeAll([{}, lt, rb]);\n  result.coord = [lt.coord, rb.coord];\n  result.x0 = lt.x;\n  result.y0 = lt.y;\n  result.x1 = rb.x;\n  result.y1 = rb.y;\n  return result;\n};\n\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markArea has one dim\n\n\nfunction ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);\n}\n\nfunction markAreaFilter(coordSys, item) {\n  var fromCoord = item.coord[0];\n  var toCoord = item.coord[1];\n\n  if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n    // In case\n    // {\n    //  markArea: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, {\n    coord: fromCoord,\n    x: item.x0,\n    y: item.y0\n  }) || markerHelper.dataFilter(coordSys, {\n    coord: toCoord,\n    x: item.x1,\n    y: item.y1\n  });\n} // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n\n\nfunction getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));\n    } else {\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      var pt = [x, y];\n      coordSys.clampData && coordSys.clampData(pt, pt);\n      point = coordSys.dataToPoint(pt, true);\n    }\n\n    if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n\n      if (isInifinity(x)) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n      } else if (isInifinity(y)) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  return point;\n}\n\nvar dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\nvar MarkAreaView =\n/** @class */\nfunction (_super) {\n  __extends(MarkAreaView, _super);\n\n  function MarkAreaView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkAreaView.type;\n    return _this;\n  }\n\n  MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var maModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markArea');\n\n      if (maModel) {\n        var areaData_1 = maModel.getData();\n        areaData_1.each(function (idx) {\n          var points = map(dimPermutations, function (dim) {\n            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);\n          }); // Layout\n\n          areaData_1.setItemLayout(idx, points);\n          var el = areaData_1.getItemGraphicEl(idx);\n          el.setShape('points', points);\n        });\n      }\n    }, this);\n  };\n\n  MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var areaGroupMap = this.markerGroupMap;\n    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {\n      group: new graphic.Group()\n    });\n    this.group.add(polygonGroup.group);\n    this.markKeep(polygonGroup);\n    var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter\n\n    maModel.setData(areaData); // Update visual and layout of line\n\n    areaData.each(function (idx) {\n      // Layout\n      var points = map(dimPermutations, function (dim) {\n        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n      }); // If none of the area is inside coordSys, allClipped is set to be true\n      // in layout so that label will not be displayed. See #12591\n\n      var allClipped = true;\n      each(dimPermutations, function (dim) {\n        if (!allClipped) {\n          return;\n        }\n\n        var xValue = areaData.get(dim[0], idx);\n        var yValue = areaData.get(dim[1], idx); // If is infinity, the axis should be considered not clipped\n\n        if ((isInifinity(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis('y').containData(yValue))) {\n          allClipped = false;\n        }\n      });\n      areaData.setItemLayout(idx, {\n        points: points,\n        allClipped: allClipped\n      });\n      var style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle();\n      var color = getVisualFromData(seriesData, 'color');\n\n      if (!style.fill) {\n        style.fill = color;\n\n        if (typeof style.fill === 'string') {\n          style.fill = colorUtil.modifyAlpha(style.fill, 0.4);\n        }\n      }\n\n      if (!style.stroke) {\n        style.stroke = color;\n      } // Visual\n\n\n      areaData.setItemVisual(idx, 'style', style);\n    });\n    areaData.diff(inner(polygonGroup).data).add(function (idx) {\n      var layout = areaData.getItemLayout(idx);\n\n      if (!layout.allClipped) {\n        var polygon = new graphic.Polygon({\n          shape: {\n            points: layout.points\n          }\n        });\n        areaData.setItemGraphicEl(idx, polygon);\n        polygonGroup.group.add(polygon);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(oldIdx);\n      var layout = areaData.getItemLayout(newIdx);\n\n      if (!layout.allClipped) {\n        if (polygon) {\n          graphic.updateProps(polygon, {\n            shape: {\n              points: layout.points\n            }\n          }, maModel, newIdx);\n        } else {\n          polygon = new graphic.Polygon({\n            shape: {\n              points: layout.points\n            }\n          });\n        }\n\n        areaData.setItemGraphicEl(newIdx, polygon);\n        polygonGroup.group.add(polygon);\n      } else if (polygon) {\n        polygonGroup.group.remove(polygon);\n      }\n    }).remove(function (idx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(idx);\n      polygonGroup.group.remove(polygon);\n    }).execute();\n    areaData.eachItemGraphicEl(function (polygon, idx) {\n      var itemModel = areaData.getItemModel(idx);\n      var style = areaData.getItemVisual(idx, 'style');\n      polygon.useStyle(areaData.getItemVisual(idx, 'style'));\n      setLabelStyle(polygon, getLabelStatesModels(itemModel), {\n        labelFetcher: maModel,\n        labelDataIndex: idx,\n        defaultText: areaData.getName(idx) || '',\n        inheritColor: typeof style.fill === 'string' ? colorUtil.modifyAlpha(style.fill, 1) : '#000'\n      });\n      setStatesStylesFromModel(polygon, itemModel);\n      enableHoverEmphasis(polygon);\n      getECData(polygon).dataModel = maModel;\n    });\n    inner(polygonGroup).data = areaData;\n    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n  };\n\n  MarkAreaView.type = 'markArea';\n  return MarkAreaView;\n}(MarkerView);\n\nfunction createList(coordSys, seriesModel, maModel) {\n  var coordDimsInfos;\n  var areaData;\n  var dims = ['x0', 'y0', 'x1', 'y1'];\n\n  if (coordSys) {\n    coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n      var data = seriesModel.getData();\n      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return defaults({\n        name: coordDim\n      }, info);\n    });\n    areaData = new List(map(dims, function (dim, idx) {\n      return {\n        name: dim,\n        type: coordDimsInfos[idx % 2].type\n      };\n    }), maModel);\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n    areaData = new List(coordDimsInfos, maModel);\n  }\n\n  var optData = map(maModel.get('data'), curry(markAreaTransform, seriesModel, coordSys, maModel));\n\n  if (coordSys) {\n    optData = filter(optData, curry(markAreaFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n    // TODO should convert to ParsedValue?\n    return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n  } : function (item) {\n    return item.value;\n  };\n  areaData.initData(optData, null, dimValueGetter);\n  areaData.hasItemOption = true;\n  return areaData;\n}\n\nexport default MarkAreaView;","map":{"version":3,"sources":["/home/kzj/project/finalize/B-S-/源码/react_code/node_modules/echarts/lib/component/marker/MarkAreaView.js"],"names":["__extends","colorUtil","List","numberUtil","graphic","enableHoverEmphasis","setStatesStylesFromModel","markerHelper","MarkerView","retrieve","mergeAll","map","defaults","curry","filter","each","isCoordinateSystemType","MarkerModel","makeInner","getVisualFromData","setLabelStyle","getLabelStatesModels","getECData","inner","markAreaTransform","seriesModel","coordSys","maModel","item","lt","dataTransform","rb","ltCoord","coord","rbCoord","Infinity","result","x0","x","y0","y","x1","y1","isInifinity","val","isNaN","isFinite","ifMarkAreaHasOnlyDim","dimIndex","fromCoord","toCoord","otherDimIndex","markAreaFilter","dataFilter","getSingleMarkerEndPoint","data","idx","dims","api","coordinateSystem","itemModel","getItemModel","point","xPx","parsePercent","get","getWidth","yPx","getHeight","getMarkerPosition","getValues","pt","clampData","dataToPoint","xAxis","getAxis","yAxis","toGlobalCoord","getExtent","dimPermutations","MarkAreaView","_super","_this","apply","arguments","type","prototype","updateTransform","markAreaModel","ecModel","eachSeries","getMarkerModelFromSeries","areaData_1","getData","points","dim","setItemLayout","el","getItemGraphicEl","setShape","renderSeries","seriesId","id","seriesData","areaGroupMap","markerGroupMap","polygonGroup","set","group","Group","add","markKeep","areaData","createList","setData","allClipped","xValue","yValue","containData","style","getModel","getItemStyle","color","fill","modifyAlpha","stroke","setItemVisual","diff","layout","getItemLayout","polygon","Polygon","shape","setItemGraphicEl","update","newIdx","oldIdx","updateProps","remove","execute","eachItemGraphicEl","getItemVisual","useStyle","labelFetcher","labelDataIndex","defaultText","getName","inheritColor","dataModel","silent","coordDimsInfos","dimensions","coordDim","info","getDimensionInfo","mapDimension","name","optData","dimValueGetter","dimName","dataIndex","Math","floor","value","initData","hasItemOption"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,OAA1B,C,CAAmC;;AAEnC,OAAO,KAAKC,SAAZ,MAA2B,wBAA3B;AACA,OAAOC,IAAP,MAAiB,iBAAjB;AACA,OAAO,KAAKC,UAAZ,MAA4B,mBAA5B;AACA,OAAO,KAAKC,OAAZ,MAAyB,oBAAzB;AACA,SAASC,mBAAT,EAA8BC,wBAA9B,QAA8D,mBAA9D;AACA,OAAO,KAAKC,YAAZ,MAA8B,gBAA9B;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,SAASC,QAAT,EAAmBC,QAAnB,EAA6BC,GAA7B,EAAkCC,QAAlC,EAA4CC,KAA5C,EAAmDC,MAAnD,EAA2DC,IAA3D,QAAuE,uBAAvE;AACA,SAASC,sBAAT,QAAuC,8BAAvC;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,SAASC,SAAT,QAA0B,kBAA1B;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AACA,SAASC,aAAT,EAAwBC,oBAAxB,QAAoD,wBAApD;AACA,SAASC,SAAT,QAA0B,uBAA1B;AACA,IAAIC,KAAK,GAAGL,SAAS,EAArB;;AAEA,IAAIM,iBAAiB,GAAG,UAAUC,WAAV,EAAuBC,QAAvB,EAAiCC,OAAjC,EAA0CC,IAA1C,EAAgD;AACtE,MAAIC,EAAE,GAAGtB,YAAY,CAACuB,aAAb,CAA2BL,WAA3B,EAAwCG,IAAI,CAAC,CAAD,CAA5C,CAAT;AACA,MAAIG,EAAE,GAAGxB,YAAY,CAACuB,aAAb,CAA2BL,WAA3B,EAAwCG,IAAI,CAAC,CAAD,CAA5C,CAAT,CAFsE,CAEX;;AAE3D,MAAII,OAAO,GAAGH,EAAE,CAACI,KAAjB;AACA,MAAIC,OAAO,GAAGH,EAAE,CAACE,KAAjB;AACAD,EAAAA,OAAO,CAAC,CAAD,CAAP,GAAavB,QAAQ,CAACuB,OAAO,CAAC,CAAD,CAAR,EAAa,CAACG,QAAd,CAArB;AACAH,EAAAA,OAAO,CAAC,CAAD,CAAP,GAAavB,QAAQ,CAACuB,OAAO,CAAC,CAAD,CAAR,EAAa,CAACG,QAAd,CAArB;AACAD,EAAAA,OAAO,CAAC,CAAD,CAAP,GAAazB,QAAQ,CAACyB,OAAO,CAAC,CAAD,CAAR,EAAaC,QAAb,CAArB;AACAD,EAAAA,OAAO,CAAC,CAAD,CAAP,GAAazB,QAAQ,CAACyB,OAAO,CAAC,CAAD,CAAR,EAAaC,QAAb,CAArB,CATsE,CASzB;;AAE7C,MAAIC,MAAM,GAAG1B,QAAQ,CAAC,CAAC,EAAD,EAAKmB,EAAL,EAASE,EAAT,CAAD,CAArB;AACAK,EAAAA,MAAM,CAACH,KAAP,GAAe,CAACJ,EAAE,CAACI,KAAJ,EAAWF,EAAE,CAACE,KAAd,CAAf;AACAG,EAAAA,MAAM,CAACC,EAAP,GAAYR,EAAE,CAACS,CAAf;AACAF,EAAAA,MAAM,CAACG,EAAP,GAAYV,EAAE,CAACW,CAAf;AACAJ,EAAAA,MAAM,CAACK,EAAP,GAAYV,EAAE,CAACO,CAAf;AACAF,EAAAA,MAAM,CAACM,EAAP,GAAYX,EAAE,CAACS,CAAf;AACA,SAAOJ,MAAP;AACD,CAlBD;;AAoBA,SAASO,WAAT,CAAqBC,GAArB,EAA0B;AACxB,SAAO,CAACC,KAAK,CAACD,GAAD,CAAN,IAAe,CAACE,QAAQ,CAACF,GAAD,CAA/B;AACD,C,CAAC;;;AAGF,SAASG,oBAAT,CAA8BC,QAA9B,EAAwCC,SAAxC,EAAmDC,OAAnD,EAA4DxB,QAA5D,EAAsE;AACpE,MAAIyB,aAAa,GAAG,IAAIH,QAAxB;AACA,SAAOL,WAAW,CAACM,SAAS,CAACE,aAAD,CAAV,CAAX,IAAyCR,WAAW,CAACO,OAAO,CAACC,aAAD,CAAR,CAA3D;AACD;;AAED,SAASC,cAAT,CAAwB1B,QAAxB,EAAkCE,IAAlC,EAAwC;AACtC,MAAIqB,SAAS,GAAGrB,IAAI,CAACK,KAAL,CAAW,CAAX,CAAhB;AACA,MAAIiB,OAAO,GAAGtB,IAAI,CAACK,KAAL,CAAW,CAAX,CAAd;;AAEA,MAAIjB,sBAAsB,CAACU,QAAD,EAAW,aAAX,CAA1B,EAAqD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,QAAIuB,SAAS,IAAIC,OAAb,KAAyBH,oBAAoB,CAAC,CAAD,EAAIE,SAAJ,EAAeC,OAAf,EAAwBxB,QAAxB,CAApB,IAAyDqB,oBAAoB,CAAC,CAAD,EAAIE,SAAJ,EAAeC,OAAf,EAAwBxB,QAAxB,CAAtG,CAAJ,EAA8I;AAC5I,aAAO,IAAP;AACD;AACF;;AAED,SAAOnB,YAAY,CAAC8C,UAAb,CAAwB3B,QAAxB,EAAkC;AACvCO,IAAAA,KAAK,EAAEgB,SADgC;AAEvCX,IAAAA,CAAC,EAAEV,IAAI,CAACS,EAF+B;AAGvCG,IAAAA,CAAC,EAAEZ,IAAI,CAACW;AAH+B,GAAlC,KAIDhC,YAAY,CAAC8C,UAAb,CAAwB3B,QAAxB,EAAkC;AACtCO,IAAAA,KAAK,EAAEiB,OAD+B;AAEtCZ,IAAAA,CAAC,EAAEV,IAAI,CAACa,EAF8B;AAGtCD,IAAAA,CAAC,EAAEZ,IAAI,CAACc;AAH8B,GAAlC,CAJN;AASD,C,CAAC;;;AAGF,SAASY,uBAAT,CAAiCC,IAAjC,EAAuCC,GAAvC,EAA4CC,IAA5C,EAAkDhC,WAAlD,EAA+DiC,GAA/D,EAAoE;AAClE,MAAIhC,QAAQ,GAAGD,WAAW,CAACkC,gBAA3B;AACA,MAAIC,SAAS,GAAGL,IAAI,CAACM,YAAL,CAAkBL,GAAlB,CAAhB;AACA,MAAIM,KAAJ;AACA,MAAIC,GAAG,GAAG5D,UAAU,CAAC6D,YAAX,CAAwBJ,SAAS,CAACK,GAAV,CAAcR,IAAI,CAAC,CAAD,CAAlB,CAAxB,EAAgDC,GAAG,CAACQ,QAAJ,EAAhD,CAAV;AACA,MAAIC,GAAG,GAAGhE,UAAU,CAAC6D,YAAX,CAAwBJ,SAAS,CAACK,GAAV,CAAcR,IAAI,CAAC,CAAD,CAAlB,CAAxB,EAAgDC,GAAG,CAACU,SAAJ,EAAhD,CAAV;;AAEA,MAAI,CAACvB,KAAK,CAACkB,GAAD,CAAN,IAAe,CAAClB,KAAK,CAACsB,GAAD,CAAzB,EAAgC;AAC9BL,IAAAA,KAAK,GAAG,CAACC,GAAD,EAAMI,GAAN,CAAR;AACD,GAFD,MAEO;AACL;AACA,QAAI1C,WAAW,CAAC4C,iBAAhB,EAAmC;AACjC;AACAP,MAAAA,KAAK,GAAGrC,WAAW,CAAC4C,iBAAZ,CAA8Bd,IAAI,CAACe,SAAL,CAAeb,IAAf,EAAqBD,GAArB,CAA9B,CAAR;AACD,KAHD,MAGO;AACL,UAAIlB,CAAC,GAAGiB,IAAI,CAACU,GAAL,CAASR,IAAI,CAAC,CAAD,CAAb,EAAkBD,GAAlB,CAAR;AACA,UAAIhB,CAAC,GAAGe,IAAI,CAACU,GAAL,CAASR,IAAI,CAAC,CAAD,CAAb,EAAkBD,GAAlB,CAAR;AACA,UAAIe,EAAE,GAAG,CAACjC,CAAD,EAAIE,CAAJ,CAAT;AACAd,MAAAA,QAAQ,CAAC8C,SAAT,IAAsB9C,QAAQ,CAAC8C,SAAT,CAAmBD,EAAnB,EAAuBA,EAAvB,CAAtB;AACAT,MAAAA,KAAK,GAAGpC,QAAQ,CAAC+C,WAAT,CAAqBF,EAArB,EAAyB,IAAzB,CAAR;AACD;;AAED,QAAIvD,sBAAsB,CAACU,QAAD,EAAW,aAAX,CAA1B,EAAqD;AACnD;AACA,UAAIgD,KAAK,GAAGhD,QAAQ,CAACiD,OAAT,CAAiB,GAAjB,CAAZ;AACA,UAAIC,KAAK,GAAGlD,QAAQ,CAACiD,OAAT,CAAiB,GAAjB,CAAZ;AACA,UAAIrC,CAAC,GAAGiB,IAAI,CAACU,GAAL,CAASR,IAAI,CAAC,CAAD,CAAb,EAAkBD,GAAlB,CAAR;AACA,UAAIhB,CAAC,GAAGe,IAAI,CAACU,GAAL,CAASR,IAAI,CAAC,CAAD,CAAb,EAAkBD,GAAlB,CAAR;;AAEA,UAAIb,WAAW,CAACL,CAAD,CAAf,EAAoB;AAClBwB,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWY,KAAK,CAACG,aAAN,CAAoBH,KAAK,CAACI,SAAN,GAAkBrB,IAAI,CAAC,CAAD,CAAJ,KAAY,IAAZ,GAAmB,CAAnB,GAAuB,CAAzC,CAApB,CAAX;AACD,OAFD,MAEO,IAAId,WAAW,CAACH,CAAD,CAAf,EAAoB;AACzBsB,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWc,KAAK,CAACC,aAAN,CAAoBD,KAAK,CAACE,SAAN,GAAkBrB,IAAI,CAAC,CAAD,CAAJ,KAAY,IAAZ,GAAmB,CAAnB,GAAuB,CAAzC,CAApB,CAAX;AACD;AACF,KAzBI,CAyBH;;;AAGF,QAAI,CAACZ,KAAK,CAACkB,GAAD,CAAV,EAAiB;AACfD,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,GAAX;AACD;;AAED,QAAI,CAAClB,KAAK,CAACsB,GAAD,CAAV,EAAiB;AACfL,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWK,GAAX;AACD;AACF;;AAED,SAAOL,KAAP;AACD;;AAED,IAAIiB,eAAe,GAAG,CAAC,CAAC,IAAD,EAAO,IAAP,CAAD,EAAe,CAAC,IAAD,EAAO,IAAP,CAAf,EAA6B,CAAC,IAAD,EAAO,IAAP,CAA7B,EAA2C,CAAC,IAAD,EAAO,IAAP,CAA3C,CAAtB;;AAEA,IAAIC,YAAY;AAChB;AACA,UAAUC,MAAV,EAAkB;AAChBjF,EAAAA,SAAS,CAACgF,YAAD,EAAeC,MAAf,CAAT;;AAEA,WAASD,YAAT,GAAwB;AACtB,QAAIE,KAAK,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AAEAF,IAAAA,KAAK,CAACG,IAAN,GAAaL,YAAY,CAACK,IAA1B;AACA,WAAOH,KAAP;AACD;;AAEDF,EAAAA,YAAY,CAACM,SAAb,CAAuBC,eAAvB,GAAyC,UAAUC,aAAV,EAAyBC,OAAzB,EAAkC/B,GAAlC,EAAuC;AAC9E+B,IAAAA,OAAO,CAACC,UAAR,CAAmB,UAAUjE,WAAV,EAAuB;AACxC,UAAIE,OAAO,GAAGV,WAAW,CAAC0E,wBAAZ,CAAqClE,WAArC,EAAkD,UAAlD,CAAd;;AAEA,UAAIE,OAAJ,EAAa;AACX,YAAIiE,UAAU,GAAGjE,OAAO,CAACkE,OAAR,EAAjB;AACAD,QAAAA,UAAU,CAAC7E,IAAX,CAAgB,UAAUyC,GAAV,EAAe;AAC7B,cAAIsC,MAAM,GAAGnF,GAAG,CAACoE,eAAD,EAAkB,UAAUgB,GAAV,EAAe;AAC/C,mBAAOzC,uBAAuB,CAACsC,UAAD,EAAapC,GAAb,EAAkBuC,GAAlB,EAAuBtE,WAAvB,EAAoCiC,GAApC,CAA9B;AACD,WAFe,CAAhB,CAD6B,CAGzB;;AAEJkC,UAAAA,UAAU,CAACI,aAAX,CAAyBxC,GAAzB,EAA8BsC,MAA9B;AACA,cAAIG,EAAE,GAAGL,UAAU,CAACM,gBAAX,CAA4B1C,GAA5B,CAAT;AACAyC,UAAAA,EAAE,CAACE,QAAH,CAAY,QAAZ,EAAsBL,MAAtB;AACD,SARD;AASD;AACF,KAfD,EAeG,IAfH;AAgBD,GAjBD;;AAmBAd,EAAAA,YAAY,CAACM,SAAb,CAAuBc,YAAvB,GAAsC,UAAU3E,WAAV,EAAuBE,OAAvB,EAAgC8D,OAAhC,EAAyC/B,GAAzC,EAA8C;AAClF,QAAIhC,QAAQ,GAAGD,WAAW,CAACkC,gBAA3B;AACA,QAAI0C,QAAQ,GAAG5E,WAAW,CAAC6E,EAA3B;AACA,QAAIC,UAAU,GAAG9E,WAAW,CAACoE,OAAZ,EAAjB;AACA,QAAIW,YAAY,GAAG,KAAKC,cAAxB;AACA,QAAIC,YAAY,GAAGF,YAAY,CAACvC,GAAb,CAAiBoC,QAAjB,KAA8BG,YAAY,CAACG,GAAb,CAAiBN,QAAjB,EAA2B;AAC1EO,MAAAA,KAAK,EAAE,IAAIxG,OAAO,CAACyG,KAAZ;AADmE,KAA3B,CAAjD;AAGA,SAAKD,KAAL,CAAWE,GAAX,CAAeJ,YAAY,CAACE,KAA5B;AACA,SAAKG,QAAL,CAAcL,YAAd;AACA,QAAIM,QAAQ,GAAGC,UAAU,CAACvF,QAAD,EAAWD,WAAX,EAAwBE,OAAxB,CAAzB,CAVkF,CAUvB;;AAE3DA,IAAAA,OAAO,CAACuF,OAAR,CAAgBF,QAAhB,EAZkF,CAYvD;;AAE3BA,IAAAA,QAAQ,CAACjG,IAAT,CAAc,UAAUyC,GAAV,EAAe;AAC3B;AACA,UAAIsC,MAAM,GAAGnF,GAAG,CAACoE,eAAD,EAAkB,UAAUgB,GAAV,EAAe;AAC/C,eAAOzC,uBAAuB,CAAC0D,QAAD,EAAWxD,GAAX,EAAgBuC,GAAhB,EAAqBtE,WAArB,EAAkCiC,GAAlC,CAA9B;AACD,OAFe,CAAhB,CAF2B,CAIvB;AACJ;;AAEA,UAAIyD,UAAU,GAAG,IAAjB;AACApG,MAAAA,IAAI,CAACgE,eAAD,EAAkB,UAAUgB,GAAV,EAAe;AACnC,YAAI,CAACoB,UAAL,EAAiB;AACf;AACD;;AAED,YAAIC,MAAM,GAAGJ,QAAQ,CAAC/C,GAAT,CAAa8B,GAAG,CAAC,CAAD,CAAhB,EAAqBvC,GAArB,CAAb;AACA,YAAI6D,MAAM,GAAGL,QAAQ,CAAC/C,GAAT,CAAa8B,GAAG,CAAC,CAAD,CAAhB,EAAqBvC,GAArB,CAAb,CANmC,CAMK;;AAExC,YAAI,CAACb,WAAW,CAACyE,MAAD,CAAX,IAAuB1F,QAAQ,CAACiD,OAAT,CAAiB,GAAjB,EAAsB2C,WAAtB,CAAkCF,MAAlC,CAAxB,MAAuEzE,WAAW,CAAC0E,MAAD,CAAX,IAAuB3F,QAAQ,CAACiD,OAAT,CAAiB,GAAjB,EAAsB2C,WAAtB,CAAkCD,MAAlC,CAA9F,CAAJ,EAA8I;AAC5IF,UAAAA,UAAU,GAAG,KAAb;AACD;AACF,OAXG,CAAJ;AAYAH,MAAAA,QAAQ,CAAChB,aAAT,CAAuBxC,GAAvB,EAA4B;AAC1BsC,QAAAA,MAAM,EAAEA,MADkB;AAE1BqB,QAAAA,UAAU,EAAEA;AAFc,OAA5B;AAIA,UAAII,KAAK,GAAGP,QAAQ,CAACnD,YAAT,CAAsBL,GAAtB,EAA2BgE,QAA3B,CAAoC,WAApC,EAAiDC,YAAjD,EAAZ;AACA,UAAIC,KAAK,GAAGvG,iBAAiB,CAACoF,UAAD,EAAa,OAAb,CAA7B;;AAEA,UAAI,CAACgB,KAAK,CAACI,IAAX,EAAiB;AACfJ,QAAAA,KAAK,CAACI,IAAN,GAAaD,KAAb;;AAEA,YAAI,OAAOH,KAAK,CAACI,IAAb,KAAsB,QAA1B,EAAoC;AAClCJ,UAAAA,KAAK,CAACI,IAAN,GAAa1H,SAAS,CAAC2H,WAAV,CAAsBL,KAAK,CAACI,IAA5B,EAAkC,GAAlC,CAAb;AACD;AACF;;AAED,UAAI,CAACJ,KAAK,CAACM,MAAX,EAAmB;AACjBN,QAAAA,KAAK,CAACM,MAAN,GAAeH,KAAf;AACD,OArC0B,CAqCzB;;;AAGFV,MAAAA,QAAQ,CAACc,aAAT,CAAuBtE,GAAvB,EAA4B,OAA5B,EAAqC+D,KAArC;AACD,KAzCD;AA0CAP,IAAAA,QAAQ,CAACe,IAAT,CAAcxG,KAAK,CAACmF,YAAD,CAAL,CAAoBnD,IAAlC,EAAwCuD,GAAxC,CAA4C,UAAUtD,GAAV,EAAe;AACzD,UAAIwE,MAAM,GAAGhB,QAAQ,CAACiB,aAAT,CAAuBzE,GAAvB,CAAb;;AAEA,UAAI,CAACwE,MAAM,CAACb,UAAZ,EAAwB;AACtB,YAAIe,OAAO,GAAG,IAAI9H,OAAO,CAAC+H,OAAZ,CAAoB;AAChCC,UAAAA,KAAK,EAAE;AACLtC,YAAAA,MAAM,EAAEkC,MAAM,CAAClC;AADV;AADyB,SAApB,CAAd;AAKAkB,QAAAA,QAAQ,CAACqB,gBAAT,CAA0B7E,GAA1B,EAA+B0E,OAA/B;AACAxB,QAAAA,YAAY,CAACE,KAAb,CAAmBE,GAAnB,CAAuBoB,OAAvB;AACD;AACF,KAZD,EAYGI,MAZH,CAYU,UAAUC,MAAV,EAAkBC,MAAlB,EAA0B;AAClC,UAAIN,OAAO,GAAG3G,KAAK,CAACmF,YAAD,CAAL,CAAoBnD,IAApB,CAAyB2C,gBAAzB,CAA0CsC,MAA1C,CAAd;AACA,UAAIR,MAAM,GAAGhB,QAAQ,CAACiB,aAAT,CAAuBM,MAAvB,CAAb;;AAEA,UAAI,CAACP,MAAM,CAACb,UAAZ,EAAwB;AACtB,YAAIe,OAAJ,EAAa;AACX9H,UAAAA,OAAO,CAACqI,WAAR,CAAoBP,OAApB,EAA6B;AAC3BE,YAAAA,KAAK,EAAE;AACLtC,cAAAA,MAAM,EAAEkC,MAAM,CAAClC;AADV;AADoB,WAA7B,EAIGnE,OAJH,EAIY4G,MAJZ;AAKD,SAND,MAMO;AACLL,UAAAA,OAAO,GAAG,IAAI9H,OAAO,CAAC+H,OAAZ,CAAoB;AAC5BC,YAAAA,KAAK,EAAE;AACLtC,cAAAA,MAAM,EAAEkC,MAAM,CAAClC;AADV;AADqB,WAApB,CAAV;AAKD;;AAEDkB,QAAAA,QAAQ,CAACqB,gBAAT,CAA0BE,MAA1B,EAAkCL,OAAlC;AACAxB,QAAAA,YAAY,CAACE,KAAb,CAAmBE,GAAnB,CAAuBoB,OAAvB;AACD,OAjBD,MAiBO,IAAIA,OAAJ,EAAa;AAClBxB,QAAAA,YAAY,CAACE,KAAb,CAAmB8B,MAAnB,CAA0BR,OAA1B;AACD;AACF,KApCD,EAoCGQ,MApCH,CAoCU,UAAUlF,GAAV,EAAe;AACvB,UAAI0E,OAAO,GAAG3G,KAAK,CAACmF,YAAD,CAAL,CAAoBnD,IAApB,CAAyB2C,gBAAzB,CAA0C1C,GAA1C,CAAd;AACAkD,MAAAA,YAAY,CAACE,KAAb,CAAmB8B,MAAnB,CAA0BR,OAA1B;AACD,KAvCD,EAuCGS,OAvCH;AAwCA3B,IAAAA,QAAQ,CAAC4B,iBAAT,CAA2B,UAAUV,OAAV,EAAmB1E,GAAnB,EAAwB;AACjD,UAAII,SAAS,GAAGoD,QAAQ,CAACnD,YAAT,CAAsBL,GAAtB,CAAhB;AACA,UAAI+D,KAAK,GAAGP,QAAQ,CAAC6B,aAAT,CAAuBrF,GAAvB,EAA4B,OAA5B,CAAZ;AACA0E,MAAAA,OAAO,CAACY,QAAR,CAAiB9B,QAAQ,CAAC6B,aAAT,CAAuBrF,GAAvB,EAA4B,OAA5B,CAAjB;AACApC,MAAAA,aAAa,CAAC8G,OAAD,EAAU7G,oBAAoB,CAACuC,SAAD,CAA9B,EAA2C;AACtDmF,QAAAA,YAAY,EAAEpH,OADwC;AAEtDqH,QAAAA,cAAc,EAAExF,GAFsC;AAGtDyF,QAAAA,WAAW,EAAEjC,QAAQ,CAACkC,OAAT,CAAiB1F,GAAjB,KAAyB,EAHgB;AAItD2F,QAAAA,YAAY,EAAE,OAAO5B,KAAK,CAACI,IAAb,KAAsB,QAAtB,GAAiC1H,SAAS,CAAC2H,WAAV,CAAsBL,KAAK,CAACI,IAA5B,EAAkC,CAAlC,CAAjC,GAAwE;AAJhC,OAA3C,CAAb;AAMArH,MAAAA,wBAAwB,CAAC4H,OAAD,EAAUtE,SAAV,CAAxB;AACAvD,MAAAA,mBAAmB,CAAC6H,OAAD,CAAnB;AACA5G,MAAAA,SAAS,CAAC4G,OAAD,CAAT,CAAmBkB,SAAnB,GAA+BzH,OAA/B;AACD,KAbD;AAcAJ,IAAAA,KAAK,CAACmF,YAAD,CAAL,CAAoBnD,IAApB,GAA2ByD,QAA3B;AACAN,IAAAA,YAAY,CAACE,KAAb,CAAmByC,MAAnB,GAA4B1H,OAAO,CAACsC,GAAR,CAAY,QAAZ,KAAyBxC,WAAW,CAACwC,GAAZ,CAAgB,QAAhB,CAArD;AACD,GAhHD;;AAkHAe,EAAAA,YAAY,CAACK,IAAb,GAAoB,UAApB;AACA,SAAOL,YAAP;AACD,CAjJD,CAiJExE,UAjJF,CAFA;;AAqJA,SAASyG,UAAT,CAAoBvF,QAApB,EAA8BD,WAA9B,EAA2CE,OAA3C,EAAoD;AAClD,MAAI2H,cAAJ;AACA,MAAItC,QAAJ;AACA,MAAIvD,IAAI,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAX;;AAEA,MAAI/B,QAAJ,EAAc;AACZ4H,IAAAA,cAAc,GAAG3I,GAAG,CAACe,QAAQ,IAAIA,QAAQ,CAAC6H,UAAtB,EAAkC,UAAUC,QAAV,EAAoB;AACxE,UAAIjG,IAAI,GAAG9B,WAAW,CAACoE,OAAZ,EAAX;AACA,UAAI4D,IAAI,GAAGlG,IAAI,CAACmG,gBAAL,CAAsBnG,IAAI,CAACoG,YAAL,CAAkBH,QAAlB,CAAtB,KAAsD,EAAjE,CAFwE,CAEH;;AAErE,aAAO5I,QAAQ,CAAC;AACdgJ,QAAAA,IAAI,EAAEJ;AADQ,OAAD,EAEZC,IAFY,CAAf;AAGD,KAPmB,CAApB;AAQAzC,IAAAA,QAAQ,GAAG,IAAI9G,IAAJ,CAASS,GAAG,CAAC8C,IAAD,EAAO,UAAUsC,GAAV,EAAevC,GAAf,EAAoB;AAChD,aAAO;AACLoG,QAAAA,IAAI,EAAE7D,GADD;AAELV,QAAAA,IAAI,EAAEiE,cAAc,CAAC9F,GAAG,GAAG,CAAP,CAAd,CAAwB6B;AAFzB,OAAP;AAID,KALsB,CAAZ,EAKP1D,OALO,CAAX;AAMD,GAfD,MAeO;AACL2H,IAAAA,cAAc,GAAG,CAAC;AAChBM,MAAAA,IAAI,EAAE,OADU;AAEhBvE,MAAAA,IAAI,EAAE;AAFU,KAAD,CAAjB;AAIA2B,IAAAA,QAAQ,GAAG,IAAI9G,IAAJ,CAASoJ,cAAT,EAAyB3H,OAAzB,CAAX;AACD;;AAED,MAAIkI,OAAO,GAAGlJ,GAAG,CAACgB,OAAO,CAACsC,GAAR,CAAY,MAAZ,CAAD,EAAsBpD,KAAK,CAACW,iBAAD,EAAoBC,WAApB,EAAiCC,QAAjC,EAA2CC,OAA3C,CAA3B,CAAjB;;AAEA,MAAID,QAAJ,EAAc;AACZmI,IAAAA,OAAO,GAAG/I,MAAM,CAAC+I,OAAD,EAAUhJ,KAAK,CAACuC,cAAD,EAAiB1B,QAAjB,CAAf,CAAhB;AACD;;AAED,MAAIoI,cAAc,GAAGpI,QAAQ,GAAG,UAAUE,IAAV,EAAgBmI,OAAhB,EAAyBC,SAAzB,EAAoChH,QAApC,EAA8C;AAC5E;AACA,WAAOpB,IAAI,CAACK,KAAL,CAAWgI,IAAI,CAACC,KAAL,CAAWlH,QAAQ,GAAG,CAAtB,CAAX,EAAqCA,QAAQ,GAAG,CAAhD,CAAP;AACD,GAH4B,GAGzB,UAAUpB,IAAV,EAAgB;AAClB,WAAOA,IAAI,CAACuI,KAAZ;AACD,GALD;AAMAnD,EAAAA,QAAQ,CAACoD,QAAT,CAAkBP,OAAlB,EAA2B,IAA3B,EAAiCC,cAAjC;AACA9C,EAAAA,QAAQ,CAACqD,aAAT,GAAyB,IAAzB;AACA,SAAOrD,QAAP;AACD;;AAED,eAAehC,YAAf","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\"; // TODO Optimize on polar\n\nimport * as colorUtil from 'zrender/lib/tool/color';\nimport List from '../../data/List';\nimport * as numberUtil from '../../util/number';\nimport * as graphic from '../../util/graphic';\nimport { enableHoverEmphasis, setStatesStylesFromModel } from '../../util/states';\nimport * as markerHelper from './markerHelper';\nimport MarkerView from './MarkerView';\nimport { retrieve, mergeAll, map, defaults, curry, filter, each } from 'zrender/lib/core/util';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem';\nimport MarkerModel from './MarkerModel';\nimport { makeInner } from '../../util/model';\nimport { getVisualFromData } from '../../visual/helper';\nimport { setLabelStyle, getLabelStatesModels } from '../../label/labelStyle';\nimport { getECData } from '../../util/innerStore';\nvar inner = makeInner();\n\nvar markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n  var lt = markerHelper.dataTransform(seriesModel, item[0]);\n  var rb = markerHelper.dataTransform(seriesModel, item[1]); // FIXME make sure lt is less than rb\n\n  var ltCoord = lt.coord;\n  var rbCoord = rb.coord;\n  ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n  ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n  rbCoord[0] = retrieve(rbCoord[0], Infinity);\n  rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one\n\n  var result = mergeAll([{}, lt, rb]);\n  result.coord = [lt.coord, rb.coord];\n  result.x0 = lt.x;\n  result.y0 = lt.y;\n  result.x1 = rb.x;\n  result.y1 = rb.y;\n  return result;\n};\n\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markArea has one dim\n\n\nfunction ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);\n}\n\nfunction markAreaFilter(coordSys, item) {\n  var fromCoord = item.coord[0];\n  var toCoord = item.coord[1];\n\n  if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n    // In case\n    // {\n    //  markArea: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, {\n    coord: fromCoord,\n    x: item.x0,\n    y: item.y0\n  }) || markerHelper.dataFilter(coordSys, {\n    coord: toCoord,\n    x: item.x1,\n    y: item.y1\n  });\n} // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n\n\nfunction getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));\n    } else {\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      var pt = [x, y];\n      coordSys.clampData && coordSys.clampData(pt, pt);\n      point = coordSys.dataToPoint(pt, true);\n    }\n\n    if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n\n      if (isInifinity(x)) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n      } else if (isInifinity(y)) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  return point;\n}\n\nvar dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\nvar MarkAreaView =\n/** @class */\nfunction (_super) {\n  __extends(MarkAreaView, _super);\n\n  function MarkAreaView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkAreaView.type;\n    return _this;\n  }\n\n  MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var maModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markArea');\n\n      if (maModel) {\n        var areaData_1 = maModel.getData();\n        areaData_1.each(function (idx) {\n          var points = map(dimPermutations, function (dim) {\n            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);\n          }); // Layout\n\n          areaData_1.setItemLayout(idx, points);\n          var el = areaData_1.getItemGraphicEl(idx);\n          el.setShape('points', points);\n        });\n      }\n    }, this);\n  };\n\n  MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var areaGroupMap = this.markerGroupMap;\n    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {\n      group: new graphic.Group()\n    });\n    this.group.add(polygonGroup.group);\n    this.markKeep(polygonGroup);\n    var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter\n\n    maModel.setData(areaData); // Update visual and layout of line\n\n    areaData.each(function (idx) {\n      // Layout\n      var points = map(dimPermutations, function (dim) {\n        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n      }); // If none of the area is inside coordSys, allClipped is set to be true\n      // in layout so that label will not be displayed. See #12591\n\n      var allClipped = true;\n      each(dimPermutations, function (dim) {\n        if (!allClipped) {\n          return;\n        }\n\n        var xValue = areaData.get(dim[0], idx);\n        var yValue = areaData.get(dim[1], idx); // If is infinity, the axis should be considered not clipped\n\n        if ((isInifinity(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis('y').containData(yValue))) {\n          allClipped = false;\n        }\n      });\n      areaData.setItemLayout(idx, {\n        points: points,\n        allClipped: allClipped\n      });\n      var style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle();\n      var color = getVisualFromData(seriesData, 'color');\n\n      if (!style.fill) {\n        style.fill = color;\n\n        if (typeof style.fill === 'string') {\n          style.fill = colorUtil.modifyAlpha(style.fill, 0.4);\n        }\n      }\n\n      if (!style.stroke) {\n        style.stroke = color;\n      } // Visual\n\n\n      areaData.setItemVisual(idx, 'style', style);\n    });\n    areaData.diff(inner(polygonGroup).data).add(function (idx) {\n      var layout = areaData.getItemLayout(idx);\n\n      if (!layout.allClipped) {\n        var polygon = new graphic.Polygon({\n          shape: {\n            points: layout.points\n          }\n        });\n        areaData.setItemGraphicEl(idx, polygon);\n        polygonGroup.group.add(polygon);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(oldIdx);\n      var layout = areaData.getItemLayout(newIdx);\n\n      if (!layout.allClipped) {\n        if (polygon) {\n          graphic.updateProps(polygon, {\n            shape: {\n              points: layout.points\n            }\n          }, maModel, newIdx);\n        } else {\n          polygon = new graphic.Polygon({\n            shape: {\n              points: layout.points\n            }\n          });\n        }\n\n        areaData.setItemGraphicEl(newIdx, polygon);\n        polygonGroup.group.add(polygon);\n      } else if (polygon) {\n        polygonGroup.group.remove(polygon);\n      }\n    }).remove(function (idx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(idx);\n      polygonGroup.group.remove(polygon);\n    }).execute();\n    areaData.eachItemGraphicEl(function (polygon, idx) {\n      var itemModel = areaData.getItemModel(idx);\n      var style = areaData.getItemVisual(idx, 'style');\n      polygon.useStyle(areaData.getItemVisual(idx, 'style'));\n      setLabelStyle(polygon, getLabelStatesModels(itemModel), {\n        labelFetcher: maModel,\n        labelDataIndex: idx,\n        defaultText: areaData.getName(idx) || '',\n        inheritColor: typeof style.fill === 'string' ? colorUtil.modifyAlpha(style.fill, 1) : '#000'\n      });\n      setStatesStylesFromModel(polygon, itemModel);\n      enableHoverEmphasis(polygon);\n      getECData(polygon).dataModel = maModel;\n    });\n    inner(polygonGroup).data = areaData;\n    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n  };\n\n  MarkAreaView.type = 'markArea';\n  return MarkAreaView;\n}(MarkerView);\n\nfunction createList(coordSys, seriesModel, maModel) {\n  var coordDimsInfos;\n  var areaData;\n  var dims = ['x0', 'y0', 'x1', 'y1'];\n\n  if (coordSys) {\n    coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n      var data = seriesModel.getData();\n      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return defaults({\n        name: coordDim\n      }, info);\n    });\n    areaData = new List(map(dims, function (dim, idx) {\n      return {\n        name: dim,\n        type: coordDimsInfos[idx % 2].type\n      };\n    }), maModel);\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n    areaData = new List(coordDimsInfos, maModel);\n  }\n\n  var optData = map(maModel.get('data'), curry(markAreaTransform, seriesModel, coordSys, maModel));\n\n  if (coordSys) {\n    optData = filter(optData, curry(markAreaFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n    // TODO should convert to ParsedValue?\n    return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n  } : function (item) {\n    return item.value;\n  };\n  areaData.initData(optData, null, dimValueGetter);\n  areaData.hasItemOption = true;\n  return areaData;\n}\n\nexport default MarkAreaView;"]},"metadata":{},"sourceType":"module"}