{"ast":null,"code":"import Group from '../graphic/Group';\nimport ZRImage from '../graphic/Image';\nimport Circle from '../graphic/shape/Circle';\nimport Rect from '../graphic/shape/Rect';\nimport Ellipse from '../graphic/shape/Ellipse';\nimport Line from '../graphic/shape/Line';\nimport Path from '../graphic/Path';\nimport Polygon from '../graphic/shape/Polygon';\nimport Polyline from '../graphic/shape/Polyline';\nimport * as matrix from '../core/matrix';\nimport { createFromString } from './path';\nimport { extend, defaults, trim, each, map } from '../core/util';\nimport LinearGradient from '../graphic/LinearGradient';\nimport TSpan from '../graphic/TSpan';\nimport { parseXML } from './parseXML';\nvar DILIMITER_REG = /[\\s,]+/;\nvar nodeParsers;\n\nvar SVGParser = function () {\n  function SVGParser() {\n    this._defs = {};\n    this._root = null;\n    this._isDefine = false;\n    this._isText = false;\n  }\n\n  SVGParser.prototype.parse = function (xml, opt) {\n    opt = opt || {};\n    var svg = parseXML(xml);\n\n    if (!svg) {\n      throw new Error('Illegal svg');\n    }\n\n    var root = new Group();\n    this._root = root;\n    var viewBox = svg.getAttribute('viewBox') || '';\n    var width = parseFloat(svg.getAttribute('width') || opt.width);\n    var height = parseFloat(svg.getAttribute('height') || opt.height);\n    isNaN(width) && (width = null);\n    isNaN(height) && (height = null);\n    parseAttributes(svg, root, null, true);\n    var child = svg.firstChild;\n\n    while (child) {\n      this._parseNode(child, root);\n\n      child = child.nextSibling;\n    }\n\n    var viewBoxRect;\n    var viewBoxTransform;\n\n    if (viewBox) {\n      var viewBoxArr = trim(viewBox).split(DILIMITER_REG);\n\n      if (viewBoxArr.length >= 4) {\n        viewBoxRect = {\n          x: parseFloat(viewBoxArr[0] || 0),\n          y: parseFloat(viewBoxArr[1] || 0),\n          width: parseFloat(viewBoxArr[2]),\n          height: parseFloat(viewBoxArr[3])\n        };\n      }\n    }\n\n    if (viewBoxRect && width != null && height != null) {\n      viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n      if (!opt.ignoreViewBox) {\n        var elRoot = root;\n        root = new Group();\n        root.add(elRoot);\n        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n        elRoot.x = viewBoxTransform.x;\n        elRoot.y = viewBoxTransform.y;\n      }\n    }\n\n    if (!opt.ignoreRootClip && width != null && height != null) {\n      root.setClipPath(new Rect({\n        shape: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      }));\n    }\n\n    return {\n      root: root,\n      width: width,\n      height: height,\n      viewBoxRect: viewBoxRect,\n      viewBoxTransform: viewBoxTransform\n    };\n  };\n\n  SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n    var nodeName = xmlNode.nodeName.toLowerCase();\n\n    if (nodeName === 'defs') {\n      this._isDefine = true;\n    } else if (nodeName === 'text') {\n      this._isText = true;\n    }\n\n    var el;\n\n    if (this._isDefine) {\n      var parser = defineParsers[nodeName];\n\n      if (parser) {\n        var def = parser.call(this, xmlNode);\n        var id = xmlNode.getAttribute('id');\n\n        if (id) {\n          this._defs[id] = def;\n        }\n      }\n    } else {\n      var parser = nodeParsers[nodeName];\n\n      if (parser) {\n        el = parser.call(this, xmlNode, parentGroup);\n        parentGroup.add(el);\n      }\n    }\n\n    if (el) {\n      var child = xmlNode.firstChild;\n\n      while (child) {\n        if (child.nodeType === 1) {\n          this._parseNode(child, el);\n        }\n\n        if (child.nodeType === 3 && this._isText) {\n          this._parseText(child, el);\n        }\n\n        child = child.nextSibling;\n      }\n    }\n\n    if (nodeName === 'defs') {\n      this._isDefine = false;\n    } else if (nodeName === 'text') {\n      this._isText = false;\n    }\n  };\n\n  SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n    if (xmlNode.nodeType === 1) {\n      var dx = xmlNode.getAttribute('dx') || 0;\n      var dy = xmlNode.getAttribute('dy') || 0;\n      this._textX += parseFloat(dx);\n      this._textY += parseFloat(dy);\n    }\n\n    var text = new TSpan({\n      style: {\n        text: xmlNode.textContent\n      },\n      x: this._textX || 0,\n      y: this._textY || 0\n    });\n    inheritStyle(parentGroup, text);\n    parseAttributes(xmlNode, text, this._defs);\n    var textStyle = text.style;\n    var fontSize = textStyle.fontSize;\n\n    if (fontSize && fontSize < 9) {\n      textStyle.fontSize = 9;\n      text.scaleX *= fontSize / 9;\n      text.scaleY *= fontSize / 9;\n    }\n\n    var font = (textStyle.fontSize || textStyle.fontFamily) && [textStyle.fontStyle, textStyle.fontWeight, (textStyle.fontSize || 12) + 'px', textStyle.fontFamily || 'sans-serif'].join(' ');\n    textStyle.font = font;\n    var rect = text.getBoundingRect();\n    this._textX += rect.width;\n    parentGroup.add(text);\n    return text;\n  };\n\n  SVGParser.internalField = function () {\n    nodeParsers = {\n      'g': function (xmlNode, parentGroup) {\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'rect': function (xmlNode, parentGroup) {\n        var rect = new Rect();\n        inheritStyle(parentGroup, rect);\n        parseAttributes(xmlNode, rect, this._defs);\n        rect.setShape({\n          x: parseFloat(xmlNode.getAttribute('x') || '0'),\n          y: parseFloat(xmlNode.getAttribute('y') || '0'),\n          width: parseFloat(xmlNode.getAttribute('width') || '0'),\n          height: parseFloat(xmlNode.getAttribute('height') || '0')\n        });\n        return rect;\n      },\n      'circle': function (xmlNode, parentGroup) {\n        var circle = new Circle();\n        inheritStyle(parentGroup, circle);\n        parseAttributes(xmlNode, circle, this._defs);\n        circle.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          r: parseFloat(xmlNode.getAttribute('r') || '0')\n        });\n        return circle;\n      },\n      'line': function (xmlNode, parentGroup) {\n        var line = new Line();\n        inheritStyle(parentGroup, line);\n        parseAttributes(xmlNode, line, this._defs);\n        line.setShape({\n          x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n          y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n          x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n          y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n        });\n        return line;\n      },\n      'ellipse': function (xmlNode, parentGroup) {\n        var ellipse = new Ellipse();\n        inheritStyle(parentGroup, ellipse);\n        parseAttributes(xmlNode, ellipse, this._defs);\n        ellipse.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n          ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n        });\n        return ellipse;\n      },\n      'polygon': function (xmlNode, parentGroup) {\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polygon = new Polygon({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        inheritStyle(parentGroup, polygon);\n        parseAttributes(xmlNode, polygon, this._defs);\n        return polygon;\n      },\n      'polyline': function (xmlNode, parentGroup) {\n        var path = new Path();\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polyline = new Polyline({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        return polyline;\n      },\n      'image': function (xmlNode, parentGroup) {\n        var img = new ZRImage();\n        inheritStyle(parentGroup, img);\n        parseAttributes(xmlNode, img, this._defs);\n        img.setStyle({\n          image: xmlNode.getAttribute('xlink:href'),\n          x: +xmlNode.getAttribute('x'),\n          y: +xmlNode.getAttribute('y'),\n          width: +xmlNode.getAttribute('width'),\n          height: +xmlNode.getAttribute('height')\n        });\n        return img;\n      },\n      'text': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x') || '0';\n        var y = xmlNode.getAttribute('y') || '0';\n        var dx = xmlNode.getAttribute('dx') || '0';\n        var dy = xmlNode.getAttribute('dy') || '0';\n        this._textX = parseFloat(x) + parseFloat(dx);\n        this._textY = parseFloat(y) + parseFloat(dy);\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'tspan': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x');\n        var y = xmlNode.getAttribute('y');\n\n        if (x != null) {\n          this._textX = parseFloat(x);\n        }\n\n        if (y != null) {\n          this._textY = parseFloat(y);\n        }\n\n        var dx = xmlNode.getAttribute('dx') || 0;\n        var dy = xmlNode.getAttribute('dy') || 0;\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        this._textX += dx;\n        this._textY += dy;\n        return g;\n      },\n      'path': function (xmlNode, parentGroup) {\n        var d = xmlNode.getAttribute('d') || '';\n        var path = createFromString(d);\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        return path;\n      }\n    };\n  }();\n\n  return SVGParser;\n}();\n\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  }\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offsetStr = stop.getAttribute('offset');\n      var offset = void 0;\n\n      if (offsetStr.indexOf('%') > 0) {\n        offset = parseInt(offsetStr, 10) / 100;\n      } else if (offsetStr) {\n        offset = parseFloat(offsetStr);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.colorStops.push({\n        offset: offset,\n        color: stopColor\n      });\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var disp = el;\n  var zrStyle = disp.__inheritedStyle || {};\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  disp.style = disp.style || {};\n  zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    disp.style.lineDash = map(trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n      return parseFloat(str);\n    });\n  }\n\n  disp.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var transformOps_1 = [];\n    var m = null;\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps_1.push(type, value);\n      return '';\n    });\n\n    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n      var value = transformOps_1[i];\n      var type = transformOps_1[i - 1];\n      var valueArr = void 0;\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n          break;\n\n        case 'scale':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n          break;\n\n        case 'rotate':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(valueArr[0]));\n          break;\n\n        case 'skew':\n          valueArr = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          valueArr = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(valueArr[0]);\n          m[1] = parseFloat(valueArr[1]);\n          m[2] = parseFloat(valueArr[2]);\n          m[3] = parseFloat(valueArr[3]);\n          m[4] = parseFloat(valueArr[4]);\n          m[5] = parseFloat(valueArr[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n}\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n\nexport function makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY);\n  return {\n    scale: scale,\n    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n  };\n}\nexport function parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\nexport { parseXML };","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/zrender/lib/tool/parseSVG.js"],"names":["Group","ZRImage","Circle","Rect","Ellipse","Line","Path","Polygon","Polyline","matrix","createFromString","extend","defaults","trim","each","map","LinearGradient","TSpan","parseXML","DILIMITER_REG","nodeParsers","SVGParser","_defs","_root","_isDefine","_isText","prototype","parse","xml","opt","svg","Error","root","viewBox","getAttribute","width","parseFloat","height","isNaN","parseAttributes","child","firstChild","_parseNode","nextSibling","viewBoxRect","viewBoxTransform","viewBoxArr","split","length","x","y","makeViewBoxTransform","ignoreViewBox","elRoot","add","scaleX","scaleY","scale","ignoreRootClip","setClipPath","shape","xmlNode","parentGroup","nodeName","toLowerCase","el","parser","defineParsers","def","call","id","nodeType","_parseText","dx","dy","_textX","_textY","text","style","textContent","inheritStyle","textStyle","fontSize","font","fontFamily","fontStyle","fontWeight","join","rect","getBoundingRect","internalField","g","setShape","circle","cx","cy","r","line","x1","y1","x2","y2","ellipse","rx","ry","pointsStr","pointsArr","parsePoints","polygon","points","path","polyline","img","setStyle","image","d","parseInt","gradient","_parseGradientColorStops","stop","offsetStr","offset","indexOf","stopColor","colorStops","push","color","parent","__inheritedStyle","pointsString","list","i","attributesMap","defs","onlyInlineStyle","disp","zrStyle","parseTransformAttribute","parseStyleAttribute","svgAttrName","hasOwnProperty","attrValue","fill","getPaint","stroke","propName","textBaseline","textAlign","lineDash","str","urlRegex","urlMatch","match","url","transformRegex","node","transform","replace","transformOps_1","m","type","value","valueArr","create","translate","rotate","console","warn","setLocalTransform","styleRegex","result","styleList","lastIndex","styleRegResult","exec","Math","min","parseSVG"],"mappings":"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","sourcesContent":["import Group from '../graphic/Group';\nimport ZRImage from '../graphic/Image';\nimport Circle from '../graphic/shape/Circle';\nimport Rect from '../graphic/shape/Rect';\nimport Ellipse from '../graphic/shape/Ellipse';\nimport Line from '../graphic/shape/Line';\nimport Path from '../graphic/Path';\nimport Polygon from '../graphic/shape/Polygon';\nimport Polyline from '../graphic/shape/Polyline';\nimport * as matrix from '../core/matrix';\nimport { createFromString } from './path';\nimport { extend, defaults, trim, each, map } from '../core/util';\nimport LinearGradient from '../graphic/LinearGradient';\nimport TSpan from '../graphic/TSpan';\nimport { parseXML } from './parseXML';\nvar DILIMITER_REG = /[\\s,]+/;\nvar nodeParsers;\nvar SVGParser = (function () {\n    function SVGParser() {\n        this._defs = {};\n        this._root = null;\n        this._isDefine = false;\n        this._isText = false;\n    }\n    SVGParser.prototype.parse = function (xml, opt) {\n        opt = opt || {};\n        var svg = parseXML(xml);\n        if (!svg) {\n            throw new Error('Illegal svg');\n        }\n        var root = new Group();\n        this._root = root;\n        var viewBox = svg.getAttribute('viewBox') || '';\n        var width = parseFloat((svg.getAttribute('width') || opt.width));\n        var height = parseFloat((svg.getAttribute('height') || opt.height));\n        isNaN(width) && (width = null);\n        isNaN(height) && (height = null);\n        parseAttributes(svg, root, null, true);\n        var child = svg.firstChild;\n        while (child) {\n            this._parseNode(child, root);\n            child = child.nextSibling;\n        }\n        var viewBoxRect;\n        var viewBoxTransform;\n        if (viewBox) {\n            var viewBoxArr = trim(viewBox).split(DILIMITER_REG);\n            if (viewBoxArr.length >= 4) {\n                viewBoxRect = {\n                    x: parseFloat((viewBoxArr[0] || 0)),\n                    y: parseFloat((viewBoxArr[1] || 0)),\n                    width: parseFloat(viewBoxArr[2]),\n                    height: parseFloat(viewBoxArr[3])\n                };\n            }\n        }\n        if (viewBoxRect && width != null && height != null) {\n            viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n            if (!opt.ignoreViewBox) {\n                var elRoot = root;\n                root = new Group();\n                root.add(elRoot);\n                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n                elRoot.x = viewBoxTransform.x;\n                elRoot.y = viewBoxTransform.y;\n            }\n        }\n        if (!opt.ignoreRootClip && width != null && height != null) {\n            root.setClipPath(new Rect({\n                shape: { x: 0, y: 0, width: width, height: height }\n            }));\n        }\n        return {\n            root: root,\n            width: width,\n            height: height,\n            viewBoxRect: viewBoxRect,\n            viewBoxTransform: viewBoxTransform\n        };\n    };\n    SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n        var nodeName = xmlNode.nodeName.toLowerCase();\n        if (nodeName === 'defs') {\n            this._isDefine = true;\n        }\n        else if (nodeName === 'text') {\n            this._isText = true;\n        }\n        var el;\n        if (this._isDefine) {\n            var parser = defineParsers[nodeName];\n            if (parser) {\n                var def = parser.call(this, xmlNode);\n                var id = xmlNode.getAttribute('id');\n                if (id) {\n                    this._defs[id] = def;\n                }\n            }\n        }\n        else {\n            var parser = nodeParsers[nodeName];\n            if (parser) {\n                el = parser.call(this, xmlNode, parentGroup);\n                parentGroup.add(el);\n            }\n        }\n        if (el) {\n            var child = xmlNode.firstChild;\n            while (child) {\n                if (child.nodeType === 1) {\n                    this._parseNode(child, el);\n                }\n                if (child.nodeType === 3 && this._isText) {\n                    this._parseText(child, el);\n                }\n                child = child.nextSibling;\n            }\n        }\n        if (nodeName === 'defs') {\n            this._isDefine = false;\n        }\n        else if (nodeName === 'text') {\n            this._isText = false;\n        }\n    };\n    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n        if (xmlNode.nodeType === 1) {\n            var dx = xmlNode.getAttribute('dx') || 0;\n            var dy = xmlNode.getAttribute('dy') || 0;\n            this._textX += parseFloat(dx);\n            this._textY += parseFloat(dy);\n        }\n        var text = new TSpan({\n            style: {\n                text: xmlNode.textContent\n            },\n            x: this._textX || 0,\n            y: this._textY || 0\n        });\n        inheritStyle(parentGroup, text);\n        parseAttributes(xmlNode, text, this._defs);\n        var textStyle = text.style;\n        var fontSize = textStyle.fontSize;\n        if (fontSize && fontSize < 9) {\n            textStyle.fontSize = 9;\n            text.scaleX *= fontSize / 9;\n            text.scaleY *= fontSize / 9;\n        }\n        var font = (textStyle.fontSize || textStyle.fontFamily) && [\n            textStyle.fontStyle,\n            textStyle.fontWeight,\n            (textStyle.fontSize || 12) + 'px',\n            textStyle.fontFamily || 'sans-serif'\n        ].join(' ');\n        textStyle.font = font;\n        var rect = text.getBoundingRect();\n        this._textX += rect.width;\n        parentGroup.add(text);\n        return text;\n    };\n    SVGParser.internalField = (function () {\n        nodeParsers = {\n            'g': function (xmlNode, parentGroup) {\n                var g = new Group();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'rect': function (xmlNode, parentGroup) {\n                var rect = new Rect();\n                inheritStyle(parentGroup, rect);\n                parseAttributes(xmlNode, rect, this._defs);\n                rect.setShape({\n                    x: parseFloat(xmlNode.getAttribute('x') || '0'),\n                    y: parseFloat(xmlNode.getAttribute('y') || '0'),\n                    width: parseFloat(xmlNode.getAttribute('width') || '0'),\n                    height: parseFloat(xmlNode.getAttribute('height') || '0')\n                });\n                return rect;\n            },\n            'circle': function (xmlNode, parentGroup) {\n                var circle = new Circle();\n                inheritStyle(parentGroup, circle);\n                parseAttributes(xmlNode, circle, this._defs);\n                circle.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    r: parseFloat(xmlNode.getAttribute('r') || '0')\n                });\n                return circle;\n            },\n            'line': function (xmlNode, parentGroup) {\n                var line = new Line();\n                inheritStyle(parentGroup, line);\n                parseAttributes(xmlNode, line, this._defs);\n                line.setShape({\n                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n                });\n                return line;\n            },\n            'ellipse': function (xmlNode, parentGroup) {\n                var ellipse = new Ellipse();\n                inheritStyle(parentGroup, ellipse);\n                parseAttributes(xmlNode, ellipse, this._defs);\n                ellipse.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n                });\n                return ellipse;\n            },\n            'polygon': function (xmlNode, parentGroup) {\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polygon = new Polygon({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                inheritStyle(parentGroup, polygon);\n                parseAttributes(xmlNode, polygon, this._defs);\n                return polygon;\n            },\n            'polyline': function (xmlNode, parentGroup) {\n                var path = new Path();\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polyline = new Polyline({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                return polyline;\n            },\n            'image': function (xmlNode, parentGroup) {\n                var img = new ZRImage();\n                inheritStyle(parentGroup, img);\n                parseAttributes(xmlNode, img, this._defs);\n                img.setStyle({\n                    image: xmlNode.getAttribute('xlink:href'),\n                    x: +xmlNode.getAttribute('x'),\n                    y: +xmlNode.getAttribute('y'),\n                    width: +xmlNode.getAttribute('width'),\n                    height: +xmlNode.getAttribute('height')\n                });\n                return img;\n            },\n            'text': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x') || '0';\n                var y = xmlNode.getAttribute('y') || '0';\n                var dx = xmlNode.getAttribute('dx') || '0';\n                var dy = xmlNode.getAttribute('dy') || '0';\n                this._textX = parseFloat(x) + parseFloat(dx);\n                this._textY = parseFloat(y) + parseFloat(dy);\n                var g = new Group();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'tspan': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x');\n                var y = xmlNode.getAttribute('y');\n                if (x != null) {\n                    this._textX = parseFloat(x);\n                }\n                if (y != null) {\n                    this._textY = parseFloat(y);\n                }\n                var dx = xmlNode.getAttribute('dx') || 0;\n                var dy = xmlNode.getAttribute('dy') || 0;\n                var g = new Group();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                this._textX += dx;\n                this._textY += dy;\n                return g;\n            },\n            'path': function (xmlNode, parentGroup) {\n                var d = xmlNode.getAttribute('d') || '';\n                var path = createFromString(d);\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                return path;\n            }\n        };\n    })();\n    return SVGParser;\n}());\nvar defineParsers = {\n    'lineargradient': function (xmlNode) {\n        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n        var gradient = new LinearGradient(x1, y1, x2, y2);\n        _parseGradientColorStops(xmlNode, gradient);\n        return gradient;\n    }\n};\nfunction _parseGradientColorStops(xmlNode, gradient) {\n    var stop = xmlNode.firstChild;\n    while (stop) {\n        if (stop.nodeType === 1) {\n            var offsetStr = stop.getAttribute('offset');\n            var offset = void 0;\n            if (offsetStr.indexOf('%') > 0) {\n                offset = parseInt(offsetStr, 10) / 100;\n            }\n            else if (offsetStr) {\n                offset = parseFloat(offsetStr);\n            }\n            else {\n                offset = 0;\n            }\n            var stopColor = stop.getAttribute('stop-color') || '#000000';\n            gradient.colorStops.push({\n                offset: offset,\n                color: stopColor\n            });\n        }\n        stop = stop.nextSibling;\n    }\n}\nfunction inheritStyle(parent, child) {\n    if (parent && parent.__inheritedStyle) {\n        if (!child.__inheritedStyle) {\n            child.__inheritedStyle = {};\n        }\n        defaults(child.__inheritedStyle, parent.__inheritedStyle);\n    }\n}\nfunction parsePoints(pointsString) {\n    var list = trim(pointsString).split(DILIMITER_REG);\n    var points = [];\n    for (var i = 0; i < list.length; i += 2) {\n        var x = parseFloat(list[i]);\n        var y = parseFloat(list[i + 1]);\n        points.push([x, y]);\n    }\n    return points;\n}\nvar attributesMap = {\n    'fill': 'fill',\n    'stroke': 'stroke',\n    'stroke-width': 'lineWidth',\n    'opacity': 'opacity',\n    'fill-opacity': 'fillOpacity',\n    'stroke-opacity': 'strokeOpacity',\n    'stroke-dasharray': 'lineDash',\n    'stroke-dashoffset': 'lineDashOffset',\n    'stroke-linecap': 'lineCap',\n    'stroke-linejoin': 'lineJoin',\n    'stroke-miterlimit': 'miterLimit',\n    'font-family': 'fontFamily',\n    'font-size': 'fontSize',\n    'font-style': 'fontStyle',\n    'font-weight': 'fontWeight',\n    'text-align': 'textAlign',\n    'alignment-baseline': 'textBaseline'\n};\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n    var disp = el;\n    var zrStyle = disp.__inheritedStyle || {};\n    if (xmlNode.nodeType === 1) {\n        parseTransformAttribute(xmlNode, el);\n        extend(zrStyle, parseStyleAttribute(xmlNode));\n        if (!onlyInlineStyle) {\n            for (var svgAttrName in attributesMap) {\n                if (attributesMap.hasOwnProperty(svgAttrName)) {\n                    var attrValue = xmlNode.getAttribute(svgAttrName);\n                    if (attrValue != null) {\n                        zrStyle[attributesMap[svgAttrName]] = attrValue;\n                    }\n                }\n            }\n        }\n    }\n    disp.style = disp.style || {};\n    zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n    zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n    each([\n        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n    });\n    if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n        zrStyle.textBaseline = 'alphabetic';\n    }\n    if (zrStyle.textBaseline === 'alphabetic') {\n        zrStyle.textBaseline = 'bottom';\n    }\n    if (zrStyle.textAlign === 'start') {\n        zrStyle.textAlign = 'left';\n    }\n    if (zrStyle.textAlign === 'end') {\n        zrStyle.textAlign = 'right';\n    }\n    each(['lineDashOffset', 'lineCap', 'lineJoin',\n        'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n    });\n    if (zrStyle.lineDash) {\n        disp.style.lineDash = map(trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n            return parseFloat(str);\n        });\n    }\n    disp.__inheritedStyle = zrStyle;\n}\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\nfunction getPaint(str, defs) {\n    var urlMatch = defs && str && str.match(urlRegex);\n    if (urlMatch) {\n        var url = trim(urlMatch[1]);\n        var def = defs[url];\n        return def;\n    }\n    return str;\n}\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\nfunction parseTransformAttribute(xmlNode, node) {\n    var transform = xmlNode.getAttribute('transform');\n    if (transform) {\n        transform = transform.replace(/,/g, ' ');\n        var transformOps_1 = [];\n        var m = null;\n        transform.replace(transformRegex, function (str, type, value) {\n            transformOps_1.push(type, value);\n            return '';\n        });\n        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n            var value = transformOps_1[i];\n            var type = transformOps_1[i - 1];\n            var valueArr = void 0;\n            m = m || matrix.create();\n            switch (type) {\n                case 'translate':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n                    break;\n                case 'scale':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n                    break;\n                case 'rotate':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    matrix.rotate(m, m, parseFloat(valueArr[0]));\n                    break;\n                case 'skew':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    console.warn('Skew transform is not supported yet');\n                    break;\n                case 'matrix':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    m[0] = parseFloat(valueArr[0]);\n                    m[1] = parseFloat(valueArr[1]);\n                    m[2] = parseFloat(valueArr[2]);\n                    m[3] = parseFloat(valueArr[3]);\n                    m[4] = parseFloat(valueArr[4]);\n                    m[5] = parseFloat(valueArr[5]);\n                    break;\n            }\n        }\n        node.setLocalTransform(m);\n    }\n}\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\nfunction parseStyleAttribute(xmlNode) {\n    var style = xmlNode.getAttribute('style');\n    var result = {};\n    if (!style) {\n        return result;\n    }\n    var styleList = {};\n    styleRegex.lastIndex = 0;\n    var styleRegResult;\n    while ((styleRegResult = styleRegex.exec(style)) != null) {\n        styleList[styleRegResult[1]] = styleRegResult[2];\n    }\n    for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n            result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n        }\n    }\n    return result;\n}\nexport function makeViewBoxTransform(viewBoxRect, width, height) {\n    var scaleX = width / viewBoxRect.width;\n    var scaleY = height / viewBoxRect.height;\n    var scale = Math.min(scaleX, scaleY);\n    return {\n        scale: scale,\n        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n    };\n}\nexport function parseSVG(xml, opt) {\n    var parser = new SVGParser();\n    return parser.parse(xml, opt);\n}\nexport { parseXML };\n"]},"metadata":{},"sourceType":"module"}