{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\"use strict\";\n\nvar _ = require('underscore');\n\nvar errors = require('web3-core-helpers').errors;\n\nvar formatters = require('web3-core-helpers').formatters;\n\nvar utils = require('web3-utils');\n\nvar promiEvent = require('web3-core-promievent');\n\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar TIMEOUTBLOCK = 50;\nvar POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\n\nvar CONFIRMATIONBLOCKS = 24;\n\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager; // reference to eth.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager; // reference to eth.accounts\n\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\n\n\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\n\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n\n  if (!this.inputFormatter) {\n    return args;\n  }\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n\n  return payload;\n};\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n      promiseResolved = false,\n      canUnsubscribe = true,\n      timeoutCount = 0,\n      confirmationCount = 0,\n      intervalId = null,\n      receiptJSON = '',\n      gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n      isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to; // add custom send Methods\n\n  var _ethereumCalls = [new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // attach methods to this._ethereumCall\n\n  var _ethereumCall = {};\n\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  }); // fire \"receipt\" and confirmation events and resolve after\n\n\n  var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function () {\n            clearInterval(intervalId);\n          }\n        };\n      } // if we have a valid receipt we don't need to send a request\n\n\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)). // catch error from requesting receipt\n      catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      }) // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then(function (receipt) {\n        if (!receipt || !receipt.blockHash) {\n          throw new Error('Receipt missing or blockHash null');\n        } // apply extra formatters\n\n\n        if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n          receipt = method.extraFormatters.receiptFormatter(receipt);\n        } // check if confirmation listener exists\n\n\n        if (defer.eventEmitter.listeners('confirmation').length > 0) {\n          // If there was an immediately retrieved receipt, it's already\n          // been confirmed by the direct call to checkConfirmation needed\n          // for parity instant-seal\n          if (existingReceipt === undefined || confirmationCount !== 0) {\n            defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n          }\n\n          canUnsubscribe = false;\n          confirmationCount++;\n\n          if (confirmationCount === CONFIRMATIONBLOCKS + 1) {\n            // add 1 so we account for conf 0\n            sub.unsubscribe();\n            defer.eventEmitter.removeAllListeners();\n          }\n        }\n\n        return receipt;\n      }) // CHECK for CONTRACT DEPLOYMENT\n      .then(function (receipt) {\n        if (isContractDeployment && !promiseResolved) {\n          if (!receipt.contractAddress) {\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n              promiseResolved = true;\n            }\n\n            utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject);\n\n            return;\n          }\n\n          _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n            if (!code) {\n              return;\n            }\n\n            if (code.length > 2) {\n              defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n              if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n              } else {\n                defer.resolve(receipt);\n              } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject);\n            }\n\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n\n            promiseResolved = true;\n          });\n        }\n\n        return receipt;\n      }) // CHECK for normal tx check for receipt only\n      .then(function (receipt) {\n        if (!isContractDeployment && !promiseResolved) {\n          if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n            defer.eventEmitter.emit('receipt', receipt);\n            defer.resolve(receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n            if (canUnsubscribe) {\n              defer.eventEmitter.removeAllListeners();\n            }\n          } else {\n            receiptJSON = JSON.stringify(receipt, null, 2);\n\n            if (receipt.status === false || receipt.status === '0x0') {\n              utils._fireError(new Error(\"Transaction has been reverted by the EVM:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            } else {\n              utils._fireError(new Error(\"Transaction ran out of gas. Please provide more gas:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            }\n          }\n\n          if (canUnsubscribe) {\n            sub.unsubscribe();\n          }\n\n          promiseResolved = true;\n        }\n      }) // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++; // check to see if we are http polling\n\n        if (!!isPolling) {\n          // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n          if (timeoutCount - 1 >= POLLINGTIMEOUT) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within' + POLLINGTIMEOUT + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= TIMEOUTBLOCK) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  }; // start watching for confirmation depending on the support features of the provider\n\n\n  var startWatching = function (existingReceipt) {\n    // if provider allows PUB/SUB\n    if (_.isFunction(this.requestManager.provider.on)) {\n      _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n    } else {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    }\n  }.bind(this); // first check if we already have a confirmed transaction\n\n\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\n\nvar getWallet = function (from, accounts) {\n  var wallet = null; // is index given\n\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from]; // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from; // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n\n  return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n  var method = this,\n      isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'; // || method.call === 'personal_sendTransaction'\n  // actual send function\n\n  var send = function () {\n    var defer = promiEvent(!isSendTx),\n        payload = method.toPayload(Array.prototype.slice.call(arguments)); // CALLBACK function\n\n    var sendTxCallback = function (err, result) {\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n\n      if (result instanceof Error) {\n        err = result;\n      }\n\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      } // return PROMISE\n\n\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        } // return PROMIEVENT\n\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n\n        method._confirmTransaction(defer, result, payload);\n      }\n    }; // SENDS the SIGNED SIGNATURE\n\n\n    var sendSignedTx = function (sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n\n    var sendRequest = function (payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet; // ETH_SENDTRANSACTION\n\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            return method.accounts.signTransaction(_.omit(tx, 'from'), wallet.privateKey).then(sendSignedTx);\n          } // ETH_SIGN\n\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n\n      return method.requestManager.send(payload, sendTxCallback);\n    }; // Send the actual transaction\n\n\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n\n        sendRequest(payload, method);\n      });\n    } else {\n      sendRequest(payload, method);\n    }\n\n    return defer.eventEmitter;\n  }; // necessary to attach things to the method\n\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\n\n\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\n\nmodule.exports = Method;","map":{"version":3,"sources":["/home/kzj/project/finalize/final/code/react_code/node_modules/web3-core-method/src/index.js"],"names":["_","require","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","TIMEOUTBLOCK","POLLINGTIMEOUT","CONFIRMATIONBLOCKS","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","requestManager","accounts","defaultBlock","defaultAccount","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","isFunction","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","receiptJSON","gasProvided","isObject","gas","isContractDeployment","data","from","to","_ethereumCalls","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","type","subscriptionName","outputBlockFormatter","_ethereumCall","each","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","receipt","blockHash","receiptFormatter","listeners","undefined","emit","removeAllListeners","contractAddress","getCode","e","code","contractDeployFormatter","outOfGas","gasUsed","status","JSON","stringify","startWatching","provider","on","subscribe","bind","setInterval","getWallet","wallet","isNumber","address","privateKey","toLowerCase","isSendTx","send","Array","slice","arguments","sendTxCallback","error","sendSignedTx","sign","signedPayload","extend","rawTransaction","sendRequest","tx","signTransaction","omit","signature","gasPrice","getGasPrice","request","format","module","exports"],"mappings":"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","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar TIMEOUTBLOCK = 50;\nvar POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\nvar CONFIRMATIONBLOCKS = 24;\n\nvar Method = function Method(options) {\n\n    if(!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n\n    this.requestManager = options.requestManager;\n\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n\n    return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n\n    if (!this.inputFormatter) {\n        return args;\n    }\n\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n\n    if(_.isArray(result)) {\n        return result.map(function(res){\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n\n    return payload;\n};\n\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this,\n        promiseResolved = false,\n        canUnsubscribe = true,\n        timeoutCount = 0,\n        confirmationCount = 0,\n        intervalId = null,\n        receiptJSON = '',\n        gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null,\n        isContractDeployment = _.isObject(payload.params[0]) &&\n            payload.params[0].data &&\n            payload.params[0].from &&\n            !payload.params[0].to;\n\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function (mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n\n\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n            // catch error from requesting receipt\n            .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({message: 'Failed to check for transaction receipt:', data: err}, defer.eventEmitter, defer.reject);\n            })\n            // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n            .then(function(receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0){\n                        defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                    }\n\n                    canUnsubscribe = false;\n                    confirmationCount++;\n\n                    if (confirmationCount === CONFIRMATIONBLOCKS + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n\n                return receipt;\n            })\n            // CHECK for CONTRACT DEPLOYMENT\n            .then(function(receipt) {\n\n                if (isContractDeployment && !promiseResolved) {\n\n                    if (!receipt.contractAddress) {\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n\n                        utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject);\n                        return;\n                    }\n\n                    _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n\n                        if (!code) {\n                            return;\n                        }\n\n\n                        if (code.length > 2) {\n                            defer.eventEmitter.emit('receipt', receipt);\n\n                            // if contract, return instance instead of receipt\n                            if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                            } else {\n                                defer.resolve(receipt);\n                            }\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject);\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    });\n                }\n\n                return receipt;\n            })\n            // CHECK for normal tx check for receipt only\n            .then(function(receipt) {\n\n                if (!isContractDeployment && !promiseResolved) {\n\n                    if(!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n\n                    } else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            utils._fireError(new Error(\"Transaction has been reverted by the EVM:\\n\" + receiptJSON),\n                                defer.eventEmitter, defer.reject);\n                        } else {\n                            utils._fireError(\n                                new Error(\"Transaction ran out of gas. Please provide more gas:\\n\" + receiptJSON),\n                                defer.eventEmitter, defer.reject);\n                        }\n                    }\n\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n\n            })\n            // time out the transaction if not mined after 50 blocks\n            .catch(function () {\n                timeoutCount++;\n\n                // check to see if we are http polling\n                if(!!isPolling) {\n                    // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n                    if (timeoutCount - 1 >= POLLINGTIMEOUT) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(new Error('Transaction was not mined within' + POLLINGTIMEOUT + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                } else {\n                    if (timeoutCount - 1 >= TIMEOUTBLOCK) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n\n\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.', data: err}, defer.eventEmitter, defer.reject);\n        }\n    };\n\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function(existingReceipt) {\n        // if provider allows PUB/SUB\n        if (_.isFunction(this.requestManager.provider.on)) {\n            _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n        } else {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        }\n    }.bind(this);\n\n\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n    .then(function(receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n\n        } else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n    .catch(function(){\n        if (!promiseResolved) startWatching();\n    });\n\n};\n\n\nvar getWallet = function(from, accounts) {\n    var wallet = null;\n\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n\n        // is account given\n    } else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n\n        // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n\n    return wallet;\n};\n\nMethod.prototype.buildCall = function() {\n    var method = this,\n        isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'); // || method.call === 'personal_sendTransaction'\n\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx),\n            payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            try {\n                result = method.formatOutput(result);\n            } catch(e) {\n                err = e;\n            }\n\n            if (result instanceof Error) {\n                err = result;\n            }\n\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if(err.error) {\n                    err = err.error;\n                }\n\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n\n            // return PROMISE\n            if (!isSendTx) {\n\n                if (!err) {\n                    defer.resolve(result);\n\n                }\n\n                // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit('transactionHash', result);\n\n                method._confirmTransaction(defer, result, payload);\n            }\n\n        };\n\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function(sign){\n\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n\n\n        var sendRequest = function(payload, method) {\n\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        return method.accounts.signTransaction(_.omit(tx, 'from'), wallet.privateKey).then(sendSignedTx);\n                    }\n\n                    // ETH_SIGN\n                } else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n\n\n                }\n            }\n\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n\n        // Send the actual transaction\n        if(isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n\n            getGasPrice(function (err, gasPrice) {\n\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n                sendRequest(payload, method);\n            });\n\n        } else {\n            sendRequest(payload, method);\n        }\n\n\n        return defer.eventEmitter;\n    };\n\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\n\nmodule.exports = Method;\n"]},"metadata":{},"sourceType":"script"}